"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tensorflow-models";
exports.ids = ["vendor-chunks/@tensorflow-models"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tensorflow-models/blazeface/dist/box.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tensorflow-models/blazeface/dist/box.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar tf = __webpack_require__(/*! @tensorflow/tfjs-core */ \"(ssr)/./node_modules/@tensorflow/tfjs-core/dist/tf-core.node.js\");\nexports.disposeBox = function (box) {\n    box.startEndTensor.dispose();\n    box.startPoint.dispose();\n    box.endPoint.dispose();\n};\nexports.createBox = function (startEndTensor) { return ({\n    startEndTensor: startEndTensor,\n    startPoint: tf.slice(startEndTensor, [0, 0], [-1, 2]),\n    endPoint: tf.slice(startEndTensor, [0, 2], [-1, 2])\n}); };\nexports.scaleBox = function (box, factors) {\n    var starts = tf.mul(box.startPoint, factors);\n    var ends = tf.mul(box.endPoint, factors);\n    var newCoordinates = tf.concat2d([starts, ends], 1);\n    return exports.createBox(newCoordinates);\n};\n//# sourceMappingURL=box.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3ctbW9kZWxzL2JsYXplZmFjZS9kaXN0L2JveC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFNBQVMsbUJBQU8sQ0FBQyw4RkFBdUI7QUFDeEMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWVjb21tZXJjZS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93LW1vZGVscy9ibGF6ZWZhY2UvZGlzdC9ib3guanM/NzRmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGYgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xuZXhwb3J0cy5kaXNwb3NlQm94ID0gZnVuY3Rpb24gKGJveCkge1xuICAgIGJveC5zdGFydEVuZFRlbnNvci5kaXNwb3NlKCk7XG4gICAgYm94LnN0YXJ0UG9pbnQuZGlzcG9zZSgpO1xuICAgIGJveC5lbmRQb2ludC5kaXNwb3NlKCk7XG59O1xuZXhwb3J0cy5jcmVhdGVCb3ggPSBmdW5jdGlvbiAoc3RhcnRFbmRUZW5zb3IpIHsgcmV0dXJuICh7XG4gICAgc3RhcnRFbmRUZW5zb3I6IHN0YXJ0RW5kVGVuc29yLFxuICAgIHN0YXJ0UG9pbnQ6IHRmLnNsaWNlKHN0YXJ0RW5kVGVuc29yLCBbMCwgMF0sIFstMSwgMl0pLFxuICAgIGVuZFBvaW50OiB0Zi5zbGljZShzdGFydEVuZFRlbnNvciwgWzAsIDJdLCBbLTEsIDJdKVxufSk7IH07XG5leHBvcnRzLnNjYWxlQm94ID0gZnVuY3Rpb24gKGJveCwgZmFjdG9ycykge1xuICAgIHZhciBzdGFydHMgPSB0Zi5tdWwoYm94LnN0YXJ0UG9pbnQsIGZhY3RvcnMpO1xuICAgIHZhciBlbmRzID0gdGYubXVsKGJveC5lbmRQb2ludCwgZmFjdG9ycyk7XG4gICAgdmFyIG5ld0Nvb3JkaW5hdGVzID0gdGYuY29uY2F0MmQoW3N0YXJ0cywgZW5kc10sIDEpO1xuICAgIHJldHVybiBleHBvcnRzLmNyZWF0ZUJveChuZXdDb29yZGluYXRlcyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym94LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tensorflow-models/blazeface/dist/box.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tensorflow-models/blazeface/dist/face.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tensorflow-models/blazeface/dist/face.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar tf = __webpack_require__(/*! @tensorflow/tfjs-core */ \"(ssr)/./node_modules/@tensorflow/tfjs-core/dist/tf-core.node.js\");\nvar box_1 = __webpack_require__(/*! ./box */ \"(ssr)/./node_modules/@tensorflow-models/blazeface/dist/box.js\");\nvar ANCHORS_CONFIG = {\n    'strides': [8, 16],\n    'anchors': [2, 6]\n};\n// `NUM_LANDMARKS` is a fixed property of the model.\nvar NUM_LANDMARKS = 6;\nfunction generateAnchors(width, height, outputSpec) {\n    var anchors = [];\n    for (var i = 0; i < outputSpec.strides.length; i++) {\n        var stride = outputSpec.strides[i];\n        var gridRows = Math.floor((height + stride - 1) / stride);\n        var gridCols = Math.floor((width + stride - 1) / stride);\n        var anchorsNum = outputSpec.anchors[i];\n        for (var gridY = 0; gridY < gridRows; gridY++) {\n            var anchorY = stride * (gridY + 0.5);\n            for (var gridX = 0; gridX < gridCols; gridX++) {\n                var anchorX = stride * (gridX + 0.5);\n                for (var n = 0; n < anchorsNum; n++) {\n                    anchors.push([anchorX, anchorY]);\n                }\n            }\n        }\n    }\n    return anchors;\n}\nfunction decodeBounds(boxOutputs, anchors, inputSize) {\n    var boxStarts = tf.slice(boxOutputs, [0, 1], [-1, 2]);\n    var centers = tf.add(boxStarts, anchors);\n    var boxSizes = tf.slice(boxOutputs, [0, 3], [-1, 2]);\n    var boxSizesNormalized = tf.div(boxSizes, inputSize);\n    var centersNormalized = tf.div(centers, inputSize);\n    var halfBoxSize = tf.div(boxSizesNormalized, 2);\n    var starts = tf.sub(centersNormalized, halfBoxSize);\n    var ends = tf.add(centersNormalized, halfBoxSize);\n    var startNormalized = tf.mul(starts, inputSize);\n    var endNormalized = tf.mul(ends, inputSize);\n    var concatAxis = 1;\n    return tf.concat2d([startNormalized, endNormalized], concatAxis);\n}\nfunction getInputTensorDimensions(input) {\n    return input instanceof tf.Tensor ? [input.shape[0], input.shape[1]] :\n        [input.height, input.width];\n}\nfunction flipFaceHorizontal(face, imageWidth) {\n    var flippedTopLeft, flippedBottomRight, flippedLandmarks;\n    if (face.topLeft instanceof tf.Tensor &&\n        face.bottomRight instanceof tf.Tensor) {\n        var _a = tf.tidy(function () {\n            return [\n                tf.concat([\n                    tf.slice(tf.sub(imageWidth - 1, face.topLeft), 0, 1),\n                    tf.slice(face.topLeft, 1, 1)\n                ]),\n                tf.concat([\n                    tf.sub(imageWidth - 1, tf.slice(face.bottomRight, 0, 1)),\n                    tf.slice(face.bottomRight, 1, 1)\n                ])\n            ];\n        }), topLeft = _a[0], bottomRight = _a[1];\n        flippedTopLeft = topLeft;\n        flippedBottomRight = bottomRight;\n        if (face.landmarks != null) {\n            flippedLandmarks = tf.tidy(function () {\n                var a = tf.sub(tf.tensor1d([imageWidth - 1, 0]), face.landmarks);\n                var b = tf.tensor1d([1, -1]);\n                var product = tf.mul(a, b);\n                return product;\n            });\n        }\n    }\n    else {\n        var _b = face.topLeft, topLeftX = _b[0], topLeftY = _b[1];\n        var _c = face.bottomRight, bottomRightX = _c[0], bottomRightY = _c[1];\n        flippedTopLeft = [imageWidth - 1 - topLeftX, topLeftY];\n        flippedBottomRight = [imageWidth - 1 - bottomRightX, bottomRightY];\n        if (face.landmarks != null) {\n            flippedLandmarks =\n                face.landmarks.map(function (coord) { return ([\n                    imageWidth - 1 - coord[0],\n                    coord[1]\n                ]); });\n        }\n    }\n    var flippedFace = {\n        topLeft: flippedTopLeft,\n        bottomRight: flippedBottomRight\n    };\n    if (flippedLandmarks != null) {\n        flippedFace.landmarks = flippedLandmarks;\n    }\n    if (face.probability != null) {\n        flippedFace.probability = face.probability instanceof tf.Tensor ?\n            face.probability.clone() :\n            face.probability;\n    }\n    return flippedFace;\n}\nfunction scaleBoxFromPrediction(face, scaleFactor) {\n    return tf.tidy(function () {\n        var box;\n        if (face.hasOwnProperty('box')) {\n            box = face.box;\n        }\n        else {\n            box = face;\n        }\n        return tf.squeeze(box_1.scaleBox(box, scaleFactor).startEndTensor);\n    });\n}\nvar BlazeFaceModel = /** @class */ (function () {\n    function BlazeFaceModel(model, width, height, maxFaces, iouThreshold, scoreThreshold) {\n        this.blazeFaceModel = model;\n        this.width = width;\n        this.height = height;\n        this.maxFaces = maxFaces;\n        this.anchorsData = generateAnchors(width, height, ANCHORS_CONFIG);\n        this.anchors = tf.tensor2d(this.anchorsData);\n        this.inputSizeData = [width, height];\n        this.inputSize = tf.tensor1d([width, height]);\n        this.iouThreshold = iouThreshold;\n        this.scoreThreshold = scoreThreshold;\n    }\n    BlazeFaceModel.prototype.getBoundingBoxes = function (inputImage, returnTensors, annotateBoxes) {\n        if (annotateBoxes === void 0) { annotateBoxes = true; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, detectedOutputs, boxes, scores, savedConsoleWarnFn, boxIndicesTensor, boxIndices, boundingBoxes, originalHeight, originalWidth, scaleFactor, annotatedBoxes, _loop_1, i;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = tf.tidy(function () {\n                            var resizedImage = tf.image.resizeBilinear(inputImage, [_this.width, _this.height]);\n                            var normalizedImage = tf.mul(tf.sub(tf.div(resizedImage, 255), 0.5), 2);\n                            // [1, 897, 17] 1 = batch, 897 = number of anchors\n                            var batchedPrediction = _this.blazeFaceModel.predict(normalizedImage);\n                            var prediction = tf.squeeze(batchedPrediction);\n                            var decodedBounds = decodeBounds(prediction, _this.anchors, _this.inputSize);\n                            var logits = tf.slice(prediction, [0, 0], [-1, 1]);\n                            var scores = tf.squeeze(tf.sigmoid(logits));\n                            return [prediction, decodedBounds, scores];\n                        }), detectedOutputs = _a[0], boxes = _a[1], scores = _a[2];\n                        savedConsoleWarnFn = console.warn;\n                        console.warn = function () { };\n                        boxIndicesTensor = tf.image.nonMaxSuppression(boxes, scores, this.maxFaces, this.iouThreshold, this.scoreThreshold);\n                        console.warn = savedConsoleWarnFn;\n                        return [4 /*yield*/, boxIndicesTensor.array()];\n                    case 1:\n                        boxIndices = _b.sent();\n                        boxIndicesTensor.dispose();\n                        boundingBoxes = boxIndices.map(function (boxIndex) { return tf.slice(boxes, [boxIndex, 0], [1, -1]); });\n                        if (!!returnTensors) return [3 /*break*/, 3];\n                        return [4 /*yield*/, Promise.all(boundingBoxes.map(function (boundingBox) { return __awaiter(_this, void 0, void 0, function () {\n                                var vals;\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0: return [4 /*yield*/, boundingBox.array()];\n                                        case 1:\n                                            vals = _a.sent();\n                                            boundingBox.dispose();\n                                            return [2 /*return*/, vals];\n                                    }\n                                });\n                            }); }))];\n                    case 2:\n                        boundingBoxes = _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        originalHeight = inputImage.shape[1];\n                        originalWidth = inputImage.shape[2];\n                        if (returnTensors) {\n                            scaleFactor = tf.div([originalWidth, originalHeight], this.inputSize);\n                        }\n                        else {\n                            scaleFactor = [\n                                originalWidth / this.inputSizeData[0],\n                                originalHeight / this.inputSizeData[1]\n                            ];\n                        }\n                        annotatedBoxes = [];\n                        _loop_1 = function (i) {\n                            var boundingBox = boundingBoxes[i];\n                            var annotatedBox = tf.tidy(function () {\n                                var box = boundingBox instanceof tf.Tensor ?\n                                    box_1.createBox(boundingBox) :\n                                    box_1.createBox(tf.tensor2d(boundingBox));\n                                if (!annotateBoxes) {\n                                    return box;\n                                }\n                                var boxIndex = boxIndices[i];\n                                var anchor;\n                                if (returnTensors) {\n                                    anchor = tf.slice(_this.anchors, [boxIndex, 0], [1, 2]);\n                                }\n                                else {\n                                    anchor = _this.anchorsData[boxIndex];\n                                }\n                                var landmarks = tf.reshape(tf.squeeze(tf.slice(detectedOutputs, [boxIndex, NUM_LANDMARKS - 1], [1, -1])), [NUM_LANDMARKS, -1]);\n                                var probability = tf.slice(scores, [boxIndex], [1]);\n                                return { box: box, landmarks: landmarks, probability: probability, anchor: anchor };\n                            });\n                            annotatedBoxes.push(annotatedBox);\n                        };\n                        for (i = 0; i < boundingBoxes.length; i++) {\n                            _loop_1(i);\n                        }\n                        boxes.dispose();\n                        scores.dispose();\n                        detectedOutputs.dispose();\n                        return [2 /*return*/, {\n                                boxes: annotatedBoxes,\n                                scaleFactor: scaleFactor\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * Returns an array of faces in an image.\n     *\n     * @param input The image to classify. Can be a tensor, DOM element image,\n     * video, or canvas.\n     * @param returnTensors (defaults to `false`) Whether to return tensors as\n     * opposed to values.\n     * @param flipHorizontal Whether to flip/mirror the facial keypoints\n     * horizontally. Should be true for videos that are flipped by default (e.g.\n     * webcams).\n     * @param annotateBoxes (defaults to `true`) Whether to annotate bounding\n     * boxes with additional properties such as landmarks and probability. Pass in\n     * `false` for faster inference if annotations are not needed.\n     *\n     * @return An array of detected faces, each with the following properties:\n     *  `topLeft`: the upper left coordinate of the face in the form `[x, y]`\n     *  `bottomRight`: the lower right coordinate of the face in the form `[x, y]`\n     *  `landmarks`: facial landmark coordinates\n     *  `probability`: the probability of the face being present\n     */\n    BlazeFaceModel.prototype.estimateFaces = function (input, returnTensors, flipHorizontal, annotateBoxes) {\n        if (returnTensors === void 0) { returnTensors = false; }\n        if (flipHorizontal === void 0) { flipHorizontal = false; }\n        if (annotateBoxes === void 0) { annotateBoxes = true; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, width, image, _b, boxes, scaleFactor;\n            var _this = this;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        _a = getInputTensorDimensions(input), width = _a[1];\n                        image = tf.tidy(function () {\n                            if (!(input instanceof tf.Tensor)) {\n                                input = tf.browser.fromPixels(input);\n                            }\n                            return tf.expandDims(tf.cast(input, 'float32'), 0);\n                        });\n                        return [4 /*yield*/, this.getBoundingBoxes(image, returnTensors, annotateBoxes)];\n                    case 1:\n                        _b = _c.sent(), boxes = _b.boxes, scaleFactor = _b.scaleFactor;\n                        image.dispose();\n                        if (returnTensors) {\n                            return [2 /*return*/, boxes.map(function (face) {\n                                    var scaledBox = scaleBoxFromPrediction(face, scaleFactor);\n                                    var normalizedFace = {\n                                        topLeft: tf.slice(scaledBox, [0], [2]),\n                                        bottomRight: tf.slice(scaledBox, [2], [2])\n                                    };\n                                    if (annotateBoxes) {\n                                        var _a = face, landmarks = _a.landmarks, probability = _a.probability, anchor = _a.anchor;\n                                        var normalizedLandmarks = tf.mul(tf.add(landmarks, anchor), scaleFactor);\n                                        normalizedFace.landmarks = normalizedLandmarks;\n                                        normalizedFace.probability = probability;\n                                    }\n                                    if (flipHorizontal) {\n                                        normalizedFace = flipFaceHorizontal(normalizedFace, width);\n                                    }\n                                    return normalizedFace;\n                                })];\n                        }\n                        return [2 /*return*/, Promise.all(boxes.map(function (face) { return __awaiter(_this, void 0, void 0, function () {\n                                var scaledBox, normalizedFace, boxData, _a, landmarkData, boxData, probabilityData, anchor_1, _b, scaleFactorX_1, scaleFactorY_1, scaledLandmarks;\n                                var _this = this;\n                                return __generator(this, function (_c) {\n                                    switch (_c.label) {\n                                        case 0:\n                                            scaledBox = scaleBoxFromPrediction(face, scaleFactor);\n                                            if (!!annotateBoxes) return [3 /*break*/, 2];\n                                            return [4 /*yield*/, scaledBox.array()];\n                                        case 1:\n                                            boxData = _c.sent();\n                                            normalizedFace = {\n                                                topLeft: boxData.slice(0, 2),\n                                                bottomRight: boxData.slice(2)\n                                            };\n                                            return [3 /*break*/, 4];\n                                        case 2: return [4 /*yield*/, Promise.all([face.landmarks, scaledBox, face.probability].map(function (d) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {\n                                                return [2 /*return*/, d.array()];\n                                            }); }); }))];\n                                        case 3:\n                                            _a = _c.sent(), landmarkData = _a[0], boxData = _a[1], probabilityData = _a[2];\n                                            anchor_1 = face.anchor;\n                                            _b = scaleFactor, scaleFactorX_1 = _b[0], scaleFactorY_1 = _b[1];\n                                            scaledLandmarks = landmarkData\n                                                .map(function (landmark) { return ([\n                                                (landmark[0] + anchor_1[0]) * scaleFactorX_1,\n                                                (landmark[1] + anchor_1[1]) * scaleFactorY_1\n                                            ]); });\n                                            normalizedFace = {\n                                                topLeft: boxData.slice(0, 2),\n                                                bottomRight: boxData.slice(2),\n                                                landmarks: scaledLandmarks,\n                                                probability: probabilityData\n                                            };\n                                            box_1.disposeBox(face.box);\n                                            face.landmarks.dispose();\n                                            face.probability.dispose();\n                                            _c.label = 4;\n                                        case 4:\n                                            scaledBox.dispose();\n                                            if (flipHorizontal) {\n                                                normalizedFace = flipFaceHorizontal(normalizedFace, width);\n                                            }\n                                            return [2 /*return*/, normalizedFace];\n                                    }\n                                });\n                            }); }))];\n                }\n            });\n        });\n    };\n    return BlazeFaceModel;\n}());\nexports.BlazeFaceModel = BlazeFaceModel;\n//# sourceMappingURL=face.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3ctbW9kZWxzL2JsYXplZmFjZS9kaXN0L2ZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0MsaUVBQWlFLHdCQUF3QjtBQUN6SDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxTQUFTLG1CQUFPLENBQUMsOEZBQXVCO0FBQ3hDLFlBQVksbUJBQU8sQ0FBQyw0RUFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsaURBQWlEO0FBQzlIO0FBQ0Esb0dBQW9HO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkIsSUFBSTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esb0NBQW9DLDBCQUEwQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx5Q0FBeUM7QUFDekMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKLHNEQUFzRDtBQUN4TTtBQUNBLDZDQUE2QyxJQUFJLElBQUk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCLElBQUk7QUFDakM7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktZWNvbW1lcmNlLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3ctbW9kZWxzL2JsYXplZmFjZS9kaXN0L2ZhY2UuanM/ZGRkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBib3hfMSA9IHJlcXVpcmUoXCIuL2JveFwiKTtcbnZhciBBTkNIT1JTX0NPTkZJRyA9IHtcbiAgICAnc3RyaWRlcyc6IFs4LCAxNl0sXG4gICAgJ2FuY2hvcnMnOiBbMiwgNl1cbn07XG4vLyBgTlVNX0xBTkRNQVJLU2AgaXMgYSBmaXhlZCBwcm9wZXJ0eSBvZiB0aGUgbW9kZWwuXG52YXIgTlVNX0xBTkRNQVJLUyA9IDY7XG5mdW5jdGlvbiBnZW5lcmF0ZUFuY2hvcnMod2lkdGgsIGhlaWdodCwgb3V0cHV0U3BlYykge1xuICAgIHZhciBhbmNob3JzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXRTcGVjLnN0cmlkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN0cmlkZSA9IG91dHB1dFNwZWMuc3RyaWRlc1tpXTtcbiAgICAgICAgdmFyIGdyaWRSb3dzID0gTWF0aC5mbG9vcigoaGVpZ2h0ICsgc3RyaWRlIC0gMSkgLyBzdHJpZGUpO1xuICAgICAgICB2YXIgZ3JpZENvbHMgPSBNYXRoLmZsb29yKCh3aWR0aCArIHN0cmlkZSAtIDEpIC8gc3RyaWRlKTtcbiAgICAgICAgdmFyIGFuY2hvcnNOdW0gPSBvdXRwdXRTcGVjLmFuY2hvcnNbaV07XG4gICAgICAgIGZvciAodmFyIGdyaWRZID0gMDsgZ3JpZFkgPCBncmlkUm93czsgZ3JpZFkrKykge1xuICAgICAgICAgICAgdmFyIGFuY2hvclkgPSBzdHJpZGUgKiAoZ3JpZFkgKyAwLjUpO1xuICAgICAgICAgICAgZm9yICh2YXIgZ3JpZFggPSAwOyBncmlkWCA8IGdyaWRDb2xzOyBncmlkWCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuY2hvclggPSBzdHJpZGUgKiAoZ3JpZFggKyAwLjUpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgYW5jaG9yc051bTsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcnMucHVzaChbYW5jaG9yWCwgYW5jaG9yWV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW5jaG9ycztcbn1cbmZ1bmN0aW9uIGRlY29kZUJvdW5kcyhib3hPdXRwdXRzLCBhbmNob3JzLCBpbnB1dFNpemUpIHtcbiAgICB2YXIgYm94U3RhcnRzID0gdGYuc2xpY2UoYm94T3V0cHV0cywgWzAsIDFdLCBbLTEsIDJdKTtcbiAgICB2YXIgY2VudGVycyA9IHRmLmFkZChib3hTdGFydHMsIGFuY2hvcnMpO1xuICAgIHZhciBib3hTaXplcyA9IHRmLnNsaWNlKGJveE91dHB1dHMsIFswLCAzXSwgWy0xLCAyXSk7XG4gICAgdmFyIGJveFNpemVzTm9ybWFsaXplZCA9IHRmLmRpdihib3hTaXplcywgaW5wdXRTaXplKTtcbiAgICB2YXIgY2VudGVyc05vcm1hbGl6ZWQgPSB0Zi5kaXYoY2VudGVycywgaW5wdXRTaXplKTtcbiAgICB2YXIgaGFsZkJveFNpemUgPSB0Zi5kaXYoYm94U2l6ZXNOb3JtYWxpemVkLCAyKTtcbiAgICB2YXIgc3RhcnRzID0gdGYuc3ViKGNlbnRlcnNOb3JtYWxpemVkLCBoYWxmQm94U2l6ZSk7XG4gICAgdmFyIGVuZHMgPSB0Zi5hZGQoY2VudGVyc05vcm1hbGl6ZWQsIGhhbGZCb3hTaXplKTtcbiAgICB2YXIgc3RhcnROb3JtYWxpemVkID0gdGYubXVsKHN0YXJ0cywgaW5wdXRTaXplKTtcbiAgICB2YXIgZW5kTm9ybWFsaXplZCA9IHRmLm11bChlbmRzLCBpbnB1dFNpemUpO1xuICAgIHZhciBjb25jYXRBeGlzID0gMTtcbiAgICByZXR1cm4gdGYuY29uY2F0MmQoW3N0YXJ0Tm9ybWFsaXplZCwgZW5kTm9ybWFsaXplZF0sIGNvbmNhdEF4aXMpO1xufVxuZnVuY3Rpb24gZ2V0SW5wdXRUZW5zb3JEaW1lbnNpb25zKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgdGYuVGVuc29yID8gW2lucHV0LnNoYXBlWzBdLCBpbnB1dC5zaGFwZVsxXV0gOlxuICAgICAgICBbaW5wdXQuaGVpZ2h0LCBpbnB1dC53aWR0aF07XG59XG5mdW5jdGlvbiBmbGlwRmFjZUhvcml6b250YWwoZmFjZSwgaW1hZ2VXaWR0aCkge1xuICAgIHZhciBmbGlwcGVkVG9wTGVmdCwgZmxpcHBlZEJvdHRvbVJpZ2h0LCBmbGlwcGVkTGFuZG1hcmtzO1xuICAgIGlmIChmYWNlLnRvcExlZnQgaW5zdGFuY2VvZiB0Zi5UZW5zb3IgJiZcbiAgICAgICAgZmFjZS5ib3R0b21SaWdodCBpbnN0YW5jZW9mIHRmLlRlbnNvcikge1xuICAgICAgICB2YXIgX2EgPSB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGYuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgdGYuc2xpY2UodGYuc3ViKGltYWdlV2lkdGggLSAxLCBmYWNlLnRvcExlZnQpLCAwLCAxKSxcbiAgICAgICAgICAgICAgICAgICAgdGYuc2xpY2UoZmFjZS50b3BMZWZ0LCAxLCAxKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIHRmLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgIHRmLnN1YihpbWFnZVdpZHRoIC0gMSwgdGYuc2xpY2UoZmFjZS5ib3R0b21SaWdodCwgMCwgMSkpLFxuICAgICAgICAgICAgICAgICAgICB0Zi5zbGljZShmYWNlLmJvdHRvbVJpZ2h0LCAxLCAxKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KSwgdG9wTGVmdCA9IF9hWzBdLCBib3R0b21SaWdodCA9IF9hWzFdO1xuICAgICAgICBmbGlwcGVkVG9wTGVmdCA9IHRvcExlZnQ7XG4gICAgICAgIGZsaXBwZWRCb3R0b21SaWdodCA9IGJvdHRvbVJpZ2h0O1xuICAgICAgICBpZiAoZmFjZS5sYW5kbWFya3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZmxpcHBlZExhbmRtYXJrcyA9IHRmLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gdGYuc3ViKHRmLnRlbnNvcjFkKFtpbWFnZVdpZHRoIC0gMSwgMF0pLCBmYWNlLmxhbmRtYXJrcyk7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSB0Zi50ZW5zb3IxZChbMSwgLTFdKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvZHVjdCA9IHRmLm11bChhLCBiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvZHVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgX2IgPSBmYWNlLnRvcExlZnQsIHRvcExlZnRYID0gX2JbMF0sIHRvcExlZnRZID0gX2JbMV07XG4gICAgICAgIHZhciBfYyA9IGZhY2UuYm90dG9tUmlnaHQsIGJvdHRvbVJpZ2h0WCA9IF9jWzBdLCBib3R0b21SaWdodFkgPSBfY1sxXTtcbiAgICAgICAgZmxpcHBlZFRvcExlZnQgPSBbaW1hZ2VXaWR0aCAtIDEgLSB0b3BMZWZ0WCwgdG9wTGVmdFldO1xuICAgICAgICBmbGlwcGVkQm90dG9tUmlnaHQgPSBbaW1hZ2VXaWR0aCAtIDEgLSBib3R0b21SaWdodFgsIGJvdHRvbVJpZ2h0WV07XG4gICAgICAgIGlmIChmYWNlLmxhbmRtYXJrcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmbGlwcGVkTGFuZG1hcmtzID1cbiAgICAgICAgICAgICAgICBmYWNlLmxhbmRtYXJrcy5tYXAoZnVuY3Rpb24gKGNvb3JkKSB7IHJldHVybiAoW1xuICAgICAgICAgICAgICAgICAgICBpbWFnZVdpZHRoIC0gMSAtIGNvb3JkWzBdLFxuICAgICAgICAgICAgICAgICAgICBjb29yZFsxXVxuICAgICAgICAgICAgICAgIF0pOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZmxpcHBlZEZhY2UgPSB7XG4gICAgICAgIHRvcExlZnQ6IGZsaXBwZWRUb3BMZWZ0LFxuICAgICAgICBib3R0b21SaWdodDogZmxpcHBlZEJvdHRvbVJpZ2h0XG4gICAgfTtcbiAgICBpZiAoZmxpcHBlZExhbmRtYXJrcyAhPSBudWxsKSB7XG4gICAgICAgIGZsaXBwZWRGYWNlLmxhbmRtYXJrcyA9IGZsaXBwZWRMYW5kbWFya3M7XG4gICAgfVxuICAgIGlmIChmYWNlLnByb2JhYmlsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgZmxpcHBlZEZhY2UucHJvYmFiaWxpdHkgPSBmYWNlLnByb2JhYmlsaXR5IGluc3RhbmNlb2YgdGYuVGVuc29yID9cbiAgICAgICAgICAgIGZhY2UucHJvYmFiaWxpdHkuY2xvbmUoKSA6XG4gICAgICAgICAgICBmYWNlLnByb2JhYmlsaXR5O1xuICAgIH1cbiAgICByZXR1cm4gZmxpcHBlZEZhY2U7XG59XG5mdW5jdGlvbiBzY2FsZUJveEZyb21QcmVkaWN0aW9uKGZhY2UsIHNjYWxlRmFjdG9yKSB7XG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm94O1xuICAgICAgICBpZiAoZmFjZS5oYXNPd25Qcm9wZXJ0eSgnYm94JykpIHtcbiAgICAgICAgICAgIGJveCA9IGZhY2UuYm94O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm94ID0gZmFjZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGYuc3F1ZWV6ZShib3hfMS5zY2FsZUJveChib3gsIHNjYWxlRmFjdG9yKS5zdGFydEVuZFRlbnNvcik7XG4gICAgfSk7XG59XG52YXIgQmxhemVGYWNlTW9kZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmxhemVGYWNlTW9kZWwobW9kZWwsIHdpZHRoLCBoZWlnaHQsIG1heEZhY2VzLCBpb3VUaHJlc2hvbGQsIHNjb3JlVGhyZXNob2xkKSB7XG4gICAgICAgIHRoaXMuYmxhemVGYWNlTW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5tYXhGYWNlcyA9IG1heEZhY2VzO1xuICAgICAgICB0aGlzLmFuY2hvcnNEYXRhID0gZ2VuZXJhdGVBbmNob3JzKHdpZHRoLCBoZWlnaHQsIEFOQ0hPUlNfQ09ORklHKTtcbiAgICAgICAgdGhpcy5hbmNob3JzID0gdGYudGVuc29yMmQodGhpcy5hbmNob3JzRGF0YSk7XG4gICAgICAgIHRoaXMuaW5wdXRTaXplRGF0YSA9IFt3aWR0aCwgaGVpZ2h0XTtcbiAgICAgICAgdGhpcy5pbnB1dFNpemUgPSB0Zi50ZW5zb3IxZChbd2lkdGgsIGhlaWdodF0pO1xuICAgICAgICB0aGlzLmlvdVRocmVzaG9sZCA9IGlvdVRocmVzaG9sZDtcbiAgICAgICAgdGhpcy5zY29yZVRocmVzaG9sZCA9IHNjb3JlVGhyZXNob2xkO1xuICAgIH1cbiAgICBCbGF6ZUZhY2VNb2RlbC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3hlcyA9IGZ1bmN0aW9uIChpbnB1dEltYWdlLCByZXR1cm5UZW5zb3JzLCBhbm5vdGF0ZUJveGVzKSB7XG4gICAgICAgIGlmIChhbm5vdGF0ZUJveGVzID09PSB2b2lkIDApIHsgYW5ub3RhdGVCb3hlcyA9IHRydWU7IH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBkZXRlY3RlZE91dHB1dHMsIGJveGVzLCBzY29yZXMsIHNhdmVkQ29uc29sZVdhcm5GbiwgYm94SW5kaWNlc1RlbnNvciwgYm94SW5kaWNlcywgYm91bmRpbmdCb3hlcywgb3JpZ2luYWxIZWlnaHQsIG9yaWdpbmFsV2lkdGgsIHNjYWxlRmFjdG9yLCBhbm5vdGF0ZWRCb3hlcywgX2xvb3BfMSwgaTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRmLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNpemVkSW1hZ2UgPSB0Zi5pbWFnZS5yZXNpemVCaWxpbmVhcihpbnB1dEltYWdlLCBbX3RoaXMud2lkdGgsIF90aGlzLmhlaWdodF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkSW1hZ2UgPSB0Zi5tdWwodGYuc3ViKHRmLmRpdihyZXNpemVkSW1hZ2UsIDI1NSksIDAuNSksIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFsxLCA4OTcsIDE3XSAxID0gYmF0Y2gsIDg5NyA9IG51bWJlciBvZiBhbmNob3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhdGNoZWRQcmVkaWN0aW9uID0gX3RoaXMuYmxhemVGYWNlTW9kZWwucHJlZGljdChub3JtYWxpemVkSW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmVkaWN0aW9uID0gdGYuc3F1ZWV6ZShiYXRjaGVkUHJlZGljdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY29kZWRCb3VuZHMgPSBkZWNvZGVCb3VuZHMocHJlZGljdGlvbiwgX3RoaXMuYW5jaG9ycywgX3RoaXMuaW5wdXRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9naXRzID0gdGYuc2xpY2UocHJlZGljdGlvbiwgWzAsIDBdLCBbLTEsIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NvcmVzID0gdGYuc3F1ZWV6ZSh0Zi5zaWdtb2lkKGxvZ2l0cykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbcHJlZGljdGlvbiwgZGVjb2RlZEJvdW5kcywgc2NvcmVzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBkZXRlY3RlZE91dHB1dHMgPSBfYVswXSwgYm94ZXMgPSBfYVsxXSwgc2NvcmVzID0gX2FbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlZENvbnNvbGVXYXJuRm4gPSBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4gPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICBib3hJbmRpY2VzVGVuc29yID0gdGYuaW1hZ2Uubm9uTWF4U3VwcHJlc3Npb24oYm94ZXMsIHNjb3JlcywgdGhpcy5tYXhGYWNlcywgdGhpcy5pb3VUaHJlc2hvbGQsIHRoaXMuc2NvcmVUaHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuID0gc2F2ZWRDb25zb2xlV2FybkZuO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYm94SW5kaWNlc1RlbnNvci5hcnJheSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYm94SW5kaWNlcyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveEluZGljZXNUZW5zb3IuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRpbmdCb3hlcyA9IGJveEluZGljZXMubWFwKGZ1bmN0aW9uIChib3hJbmRleCkgeyByZXR1cm4gdGYuc2xpY2UoYm94ZXMsIFtib3hJbmRleCwgMF0sIFsxLCAtMV0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIXJldHVyblRlbnNvcnMpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwoYm91bmRpbmdCb3hlcy5tYXAoZnVuY3Rpb24gKGJvdW5kaW5nQm94KSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBib3VuZGluZ0JveC5hcnJheSgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nQm94LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZhbHNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRpbmdCb3hlcyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxIZWlnaHQgPSBpbnB1dEltYWdlLnNoYXBlWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxXaWR0aCA9IGlucHV0SW1hZ2Uuc2hhcGVbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVGVuc29ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlRmFjdG9yID0gdGYuZGl2KFtvcmlnaW5hbFdpZHRoLCBvcmlnaW5hbEhlaWdodF0sIHRoaXMuaW5wdXRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlRmFjdG9yID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFdpZHRoIC8gdGhpcy5pbnB1dFNpemVEYXRhWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEhlaWdodCAvIHRoaXMuaW5wdXRTaXplRGF0YVsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZWRCb3hlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3hlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGVkQm94ID0gdGYudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3ggPSBib3VuZGluZ0JveCBpbnN0YW5jZW9mIHRmLlRlbnNvciA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3hfMS5jcmVhdGVCb3goYm91bmRpbmdCb3gpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveF8xLmNyZWF0ZUJveCh0Zi50ZW5zb3IyZChib3VuZGluZ0JveCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFubm90YXRlQm94ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBib3g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJveEluZGV4ID0gYm94SW5kaWNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblRlbnNvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IHRmLnNsaWNlKF90aGlzLmFuY2hvcnMsIFtib3hJbmRleCwgMF0sIFsxLCAyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBfdGhpcy5hbmNob3JzRGF0YVtib3hJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmRtYXJrcyA9IHRmLnJlc2hhcGUodGYuc3F1ZWV6ZSh0Zi5zbGljZShkZXRlY3RlZE91dHB1dHMsIFtib3hJbmRleCwgTlVNX0xBTkRNQVJLUyAtIDFdLCBbMSwgLTFdKSksIFtOVU1fTEFORE1BUktTLCAtMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvYmFiaWxpdHkgPSB0Zi5zbGljZShzY29yZXMsIFtib3hJbmRleF0sIFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGJveDogYm94LCBsYW5kbWFya3M6IGxhbmRtYXJrcywgcHJvYmFiaWxpdHk6IHByb2JhYmlsaXR5LCBhbmNob3I6IGFuY2hvciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRlZEJveGVzLnB1c2goYW5ub3RhdGVkQm94KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm91bmRpbmdCb3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBib3hlcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29yZXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWRPdXRwdXRzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveGVzOiBhbm5vdGF0ZWRCb3hlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVGYWN0b3I6IHNjYWxlRmFjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBmYWNlcyBpbiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW1hZ2UgdG8gY2xhc3NpZnkuIENhbiBiZSBhIHRlbnNvciwgRE9NIGVsZW1lbnQgaW1hZ2UsXG4gICAgICogdmlkZW8sIG9yIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0gcmV0dXJuVGVuc29ycyAoZGVmYXVsdHMgdG8gYGZhbHNlYCkgV2hldGhlciB0byByZXR1cm4gdGVuc29ycyBhc1xuICAgICAqIG9wcG9zZWQgdG8gdmFsdWVzLlxuICAgICAqIEBwYXJhbSBmbGlwSG9yaXpvbnRhbCBXaGV0aGVyIHRvIGZsaXAvbWlycm9yIHRoZSBmYWNpYWwga2V5cG9pbnRzXG4gICAgICogaG9yaXpvbnRhbGx5LiBTaG91bGQgYmUgdHJ1ZSBmb3IgdmlkZW9zIHRoYXQgYXJlIGZsaXBwZWQgYnkgZGVmYXVsdCAoZS5nLlxuICAgICAqIHdlYmNhbXMpLlxuICAgICAqIEBwYXJhbSBhbm5vdGF0ZUJveGVzIChkZWZhdWx0cyB0byBgdHJ1ZWApIFdoZXRoZXIgdG8gYW5ub3RhdGUgYm91bmRpbmdcbiAgICAgKiBib3hlcyB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcyBzdWNoIGFzIGxhbmRtYXJrcyBhbmQgcHJvYmFiaWxpdHkuIFBhc3MgaW5cbiAgICAgKiBgZmFsc2VgIGZvciBmYXN0ZXIgaW5mZXJlbmNlIGlmIGFubm90YXRpb25zIGFyZSBub3QgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBBbiBhcnJheSBvZiBkZXRlY3RlZCBmYWNlcywgZWFjaCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiAgYHRvcExlZnRgOiB0aGUgdXBwZXIgbGVmdCBjb29yZGluYXRlIG9mIHRoZSBmYWNlIGluIHRoZSBmb3JtIGBbeCwgeV1gXG4gICAgICogIGBib3R0b21SaWdodGA6IHRoZSBsb3dlciByaWdodCBjb29yZGluYXRlIG9mIHRoZSBmYWNlIGluIHRoZSBmb3JtIGBbeCwgeV1gXG4gICAgICogIGBsYW5kbWFya3NgOiBmYWNpYWwgbGFuZG1hcmsgY29vcmRpbmF0ZXNcbiAgICAgKiAgYHByb2JhYmlsaXR5YDogdGhlIHByb2JhYmlsaXR5IG9mIHRoZSBmYWNlIGJlaW5nIHByZXNlbnRcbiAgICAgKi9cbiAgICBCbGF6ZUZhY2VNb2RlbC5wcm90b3R5cGUuZXN0aW1hdGVGYWNlcyA9IGZ1bmN0aW9uIChpbnB1dCwgcmV0dXJuVGVuc29ycywgZmxpcEhvcml6b250YWwsIGFubm90YXRlQm94ZXMpIHtcbiAgICAgICAgaWYgKHJldHVyblRlbnNvcnMgPT09IHZvaWQgMCkgeyByZXR1cm5UZW5zb3JzID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGZsaXBIb3Jpem9udGFsID09PSB2b2lkIDApIHsgZmxpcEhvcml6b250YWwgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoYW5ub3RhdGVCb3hlcyA9PT0gdm9pZCAwKSB7IGFubm90YXRlQm94ZXMgPSB0cnVlOyB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgd2lkdGgsIGltYWdlLCBfYiwgYm94ZXMsIHNjYWxlRmFjdG9yO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gZ2V0SW5wdXRUZW5zb3JEaW1lbnNpb25zKGlucHV0KSwgd2lkdGggPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlID0gdGYudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiB0Zi5UZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0ID0gdGYuYnJvd3Nlci5mcm9tUGl4ZWxzKGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRmLmV4cGFuZERpbXModGYuY2FzdChpbnB1dCwgJ2Zsb2F0MzInKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0Qm91bmRpbmdCb3hlcyhpbWFnZSwgcmV0dXJuVGVuc29ycywgYW5ub3RhdGVCb3hlcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IF9jLnNlbnQoKSwgYm94ZXMgPSBfYi5ib3hlcywgc2NhbGVGYWN0b3IgPSBfYi5zY2FsZUZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5UZW5zb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJveGVzLm1hcChmdW5jdGlvbiAoZmFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlZEJveCA9IHNjYWxlQm94RnJvbVByZWRpY3Rpb24oZmFjZSwgc2NhbGVGYWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRGYWNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcExlZnQ6IHRmLnNsaWNlKHNjYWxlZEJveCwgWzBdLCBbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0OiB0Zi5zbGljZShzY2FsZWRCb3gsIFsyXSwgWzJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0ZUJveGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gZmFjZSwgbGFuZG1hcmtzID0gX2EubGFuZG1hcmtzLCBwcm9iYWJpbGl0eSA9IF9hLnByb2JhYmlsaXR5LCBhbmNob3IgPSBfYS5hbmNob3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRMYW5kbWFya3MgPSB0Zi5tdWwodGYuYWRkKGxhbmRtYXJrcywgYW5jaG9yKSwgc2NhbGVGYWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRGYWNlLmxhbmRtYXJrcyA9IG5vcm1hbGl6ZWRMYW5kbWFya3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEZhY2UucHJvYmFiaWxpdHkgPSBwcm9iYWJpbGl0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbGlwSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRGYWNlID0gZmxpcEZhY2VIb3Jpem9udGFsKG5vcm1hbGl6ZWRGYWNlLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZEZhY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBQcm9taXNlLmFsbChib3hlcy5tYXAoZnVuY3Rpb24gKGZhY2UpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlZEJveCwgbm9ybWFsaXplZEZhY2UsIGJveERhdGEsIF9hLCBsYW5kbWFya0RhdGEsIGJveERhdGEsIHByb2JhYmlsaXR5RGF0YSwgYW5jaG9yXzEsIF9iLCBzY2FsZUZhY3RvclhfMSwgc2NhbGVGYWN0b3JZXzEsIHNjYWxlZExhbmRtYXJrcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkQm94ID0gc2NhbGVCb3hGcm9tUHJlZGljdGlvbihmYWNlLCBzY2FsZUZhY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIWFubm90YXRlQm94ZXMpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzY2FsZWRCb3guYXJyYXkoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3hEYXRhID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkRmFjZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcExlZnQ6IGJveERhdGEuc2xpY2UoMCwgMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b21SaWdodDogYm94RGF0YS5zbGljZSgyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKFtmYWNlLmxhbmRtYXJrcywgc2NhbGVkQm94LCBmYWNlLnByb2JhYmlsaXR5XS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGQuYXJyYXkoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KTsgfSkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gX2Muc2VudCgpLCBsYW5kbWFya0RhdGEgPSBfYVswXSwgYm94RGF0YSA9IF9hWzFdLCBwcm9iYWJpbGl0eURhdGEgPSBfYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yXzEgPSBmYWNlLmFuY2hvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSBzY2FsZUZhY3Rvciwgc2NhbGVGYWN0b3JYXzEgPSBfYlswXSwgc2NhbGVGYWN0b3JZXzEgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkTGFuZG1hcmtzID0gbGFuZG1hcmtEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChsYW5kbWFyaykgeyByZXR1cm4gKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsYW5kbWFya1swXSArIGFuY2hvcl8xWzBdKSAqIHNjYWxlRmFjdG9yWF8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxhbmRtYXJrWzFdICsgYW5jaG9yXzFbMV0pICogc2NhbGVGYWN0b3JZXzFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkRmFjZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcExlZnQ6IGJveERhdGEuc2xpY2UoMCwgMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b21SaWdodDogYm94RGF0YS5zbGljZSgyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmRtYXJrczogc2NhbGVkTGFuZG1hcmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvYmFiaWxpdHk6IHByb2JhYmlsaXR5RGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3hfMS5kaXNwb3NlQm94KGZhY2UuYm94KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjZS5sYW5kbWFya3MuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlLnByb2JhYmlsaXR5LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkQm94LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZsaXBIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkRmFjZSA9IGZsaXBGYWNlSG9yaXpvbnRhbChub3JtYWxpemVkRmFjZSwgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBub3JtYWxpemVkRmFjZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBCbGF6ZUZhY2VNb2RlbDtcbn0oKSk7XG5leHBvcnRzLkJsYXplRmFjZU1vZGVsID0gQmxhemVGYWNlTW9kZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mYWNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tensorflow-models/blazeface/dist/face.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tensorflow-models/blazeface/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tensorflow-models/blazeface/dist/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar tfconv = __webpack_require__(/*! @tensorflow/tfjs-converter */ \"(ssr)/./node_modules/@tensorflow/tfjs-converter/dist/tf-converter.node.js\");\nvar face_1 = __webpack_require__(/*! ./face */ \"(ssr)/./node_modules/@tensorflow-models/blazeface/dist/face.js\");\nvar BLAZEFACE_MODEL_URL = 'https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1';\n/**\n * Load blazeface.\n *\n * @param config A configuration object with the following properties:\n *  `maxFaces` The maximum number of faces returned by the model.\n *  `inputWidth` The width of the input image.\n *  `inputHeight` The height of the input image.\n *  `iouThreshold` The threshold for deciding whether boxes overlap too\n * much.\n *  `scoreThreshold` The threshold for deciding when to remove boxes based\n * on score.\n */\nfunction load(_a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.maxFaces, maxFaces = _c === void 0 ? 10 : _c, _d = _b.inputWidth, inputWidth = _d === void 0 ? 128 : _d, _e = _b.inputHeight, inputHeight = _e === void 0 ? 128 : _e, _f = _b.iouThreshold, iouThreshold = _f === void 0 ? 0.3 : _f, _g = _b.scoreThreshold, scoreThreshold = _g === void 0 ? 0.75 : _g, modelUrl = _b.modelUrl;\n    return __awaiter(this, void 0, void 0, function () {\n        var blazeface, model;\n        return __generator(this, function (_h) {\n            switch (_h.label) {\n                case 0:\n                    if (!(modelUrl != null)) return [3 /*break*/, 2];\n                    return [4 /*yield*/, tfconv.loadGraphModel(modelUrl)];\n                case 1:\n                    blazeface = _h.sent();\n                    return [3 /*break*/, 4];\n                case 2: return [4 /*yield*/, tfconv.loadGraphModel(BLAZEFACE_MODEL_URL, {\n                        fromTFHub: true,\n                    })];\n                case 3:\n                    blazeface = _h.sent();\n                    _h.label = 4;\n                case 4:\n                    model = new face_1.BlazeFaceModel(blazeface, inputWidth, inputHeight, maxFaces, iouThreshold, scoreThreshold);\n                    return [2 /*return*/, model];\n            }\n        });\n    });\n}\nexports.load = load;\nvar face_2 = __webpack_require__(/*! ./face */ \"(ssr)/./node_modules/@tensorflow-models/blazeface/dist/face.js\");\nexports.BlazeFaceModel = face_2.BlazeFaceModel;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3ctbW9kZWxzL2JsYXplZmFjZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDLGlFQUFpRSx3QkFBd0I7QUFDekg7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDZHQUE0QjtBQUNqRCxhQUFhLG1CQUFPLENBQUMsOEVBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsWUFBWTtBQUNaLGFBQWEsbUJBQU8sQ0FBQyw4RUFBUTtBQUM3QixzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1lY29tbWVyY2Utd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy1tb2RlbHMvYmxhemVmYWNlL2Rpc3QvaW5kZXguanM/NmU3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmY29udiA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlclwiKTtcbnZhciBmYWNlXzEgPSByZXF1aXJlKFwiLi9mYWNlXCIpO1xudmFyIEJMQVpFRkFDRV9NT0RFTF9VUkwgPSAnaHR0cHM6Ly90Zmh1Yi5kZXYvdGVuc29yZmxvdy90ZmpzLW1vZGVsL2JsYXplZmFjZS8xL2RlZmF1bHQvMSc7XG4vKipcbiAqIExvYWQgYmxhemVmYWNlLlxuICpcbiAqIEBwYXJhbSBjb25maWcgQSBjb25maWd1cmF0aW9uIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqICBgbWF4RmFjZXNgIFRoZSBtYXhpbXVtIG51bWJlciBvZiBmYWNlcyByZXR1cm5lZCBieSB0aGUgbW9kZWwuXG4gKiAgYGlucHV0V2lkdGhgIFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgaW1hZ2UuXG4gKiAgYGlucHV0SGVpZ2h0YCBUaGUgaGVpZ2h0IG9mIHRoZSBpbnB1dCBpbWFnZS5cbiAqICBgaW91VGhyZXNob2xkYCBUaGUgdGhyZXNob2xkIGZvciBkZWNpZGluZyB3aGV0aGVyIGJveGVzIG92ZXJsYXAgdG9vXG4gKiBtdWNoLlxuICogIGBzY29yZVRocmVzaG9sZGAgVGhlIHRocmVzaG9sZCBmb3IgZGVjaWRpbmcgd2hlbiB0byByZW1vdmUgYm94ZXMgYmFzZWRcbiAqIG9uIHNjb3JlLlxuICovXG5mdW5jdGlvbiBsb2FkKF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IubWF4RmFjZXMsIG1heEZhY2VzID0gX2MgPT09IHZvaWQgMCA/IDEwIDogX2MsIF9kID0gX2IuaW5wdXRXaWR0aCwgaW5wdXRXaWR0aCA9IF9kID09PSB2b2lkIDAgPyAxMjggOiBfZCwgX2UgPSBfYi5pbnB1dEhlaWdodCwgaW5wdXRIZWlnaHQgPSBfZSA9PT0gdm9pZCAwID8gMTI4IDogX2UsIF9mID0gX2IuaW91VGhyZXNob2xkLCBpb3VUaHJlc2hvbGQgPSBfZiA9PT0gdm9pZCAwID8gMC4zIDogX2YsIF9nID0gX2Iuc2NvcmVUaHJlc2hvbGQsIHNjb3JlVGhyZXNob2xkID0gX2cgPT09IHZvaWQgMCA/IDAuNzUgOiBfZywgbW9kZWxVcmwgPSBfYi5tb2RlbFVybDtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBibGF6ZWZhY2UsIG1vZGVsO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9oKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9oLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtb2RlbFVybCAhPSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRmY29udi5sb2FkR3JhcGhNb2RlbChtb2RlbFVybCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYmxhemVmYWNlID0gX2guc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRmY29udi5sb2FkR3JhcGhNb2RlbChCTEFaRUZBQ0VfTU9ERUxfVVJMLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tVEZIdWI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGJsYXplZmFjZSA9IF9oLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2gubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwgPSBuZXcgZmFjZV8xLkJsYXplRmFjZU1vZGVsKGJsYXplZmFjZSwgaW5wdXRXaWR0aCwgaW5wdXRIZWlnaHQsIG1heEZhY2VzLCBpb3VUaHJlc2hvbGQsIHNjb3JlVGhyZXNob2xkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG1vZGVsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xudmFyIGZhY2VfMiA9IHJlcXVpcmUoXCIuL2ZhY2VcIik7XG5leHBvcnRzLkJsYXplRmFjZU1vZGVsID0gZmFjZV8yLkJsYXplRmFjZU1vZGVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tensorflow-models/blazeface/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tensorflow-models/face-landmarks-detection/dist/index.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar mediapipe_facemesh_1 = __webpack_require__(/*! ./mediapipe-facemesh */ \"(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/index.js\");\nvar SupportedPackages;\n(function (SupportedPackages) {\n    SupportedPackages[\"mediapipeFacemesh\"] = \"mediapipe-facemesh\";\n})(SupportedPackages = exports.SupportedPackages || (exports.SupportedPackages = {}));\n/**\n * Load face-landmarks-detection.\n *\n * @param pkg - The name of the package to load, e.g. 'mediapipe-facemesh'.\n * @param config - a configuration object with the following properties:\n *  - `maxContinuousChecks` How many frames to go without running the bounding\n * box detector. Only relevant if maxFaces > 1. Defaults to 5.\n *  - `detectionConfidence` Threshold for discarding a prediction. Defaults to\n * 0.9.\n *  - `maxFaces` The maximum number of faces detected in the input. Should be\n * set to the minimum number for performance. Defaults to 10.\n *  - `iouThreshold` A float representing the threshold for deciding whether\n * boxes overlap too much in non-maximum suppression. Must be between [0, 1].\n * Defaults to 0.3.\n *  - `scoreThreshold` A threshold for deciding when to remove boxes based\n * on score in non-maximum suppression. Defaults to 0.75.\n *  - `shouldLoadIrisModel` Whether to also load the iris detection model.\n * Defaults to true.\n */\nfunction load(pkg, config) {\n    if (pkg === void 0) { pkg = SupportedPackages.mediapipeFacemesh; }\n    if (config === void 0) { config = {}; }\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            if (pkg === SupportedPackages.mediapipeFacemesh) {\n                return [2 /*return*/, mediapipe_facemesh_1.load(config)];\n            }\n            else {\n                throw new Error(pkg + \" is not a valid package name.\");\n            }\n            return [2 /*return*/];\n        });\n    });\n}\nexports.load = load;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3ctbW9kZWxzL2ZhY2UtbGFuZG1hcmtzLWRldGVjdGlvbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDLGlFQUFpRSx3QkFBd0I7QUFDekg7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsK0hBQXNCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0RBQW9ELHlCQUF5QixLQUFLO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxZQUFZO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1lY29tbWVyY2Utd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy1tb2RlbHMvZmFjZS1sYW5kbWFya3MtZGV0ZWN0aW9uL2Rpc3QvaW5kZXguanM/MThjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1lZGlhcGlwZV9mYWNlbWVzaF8xID0gcmVxdWlyZShcIi4vbWVkaWFwaXBlLWZhY2VtZXNoXCIpO1xudmFyIFN1cHBvcnRlZFBhY2thZ2VzO1xuKGZ1bmN0aW9uIChTdXBwb3J0ZWRQYWNrYWdlcykge1xuICAgIFN1cHBvcnRlZFBhY2thZ2VzW1wibWVkaWFwaXBlRmFjZW1lc2hcIl0gPSBcIm1lZGlhcGlwZS1mYWNlbWVzaFwiO1xufSkoU3VwcG9ydGVkUGFja2FnZXMgPSBleHBvcnRzLlN1cHBvcnRlZFBhY2thZ2VzIHx8IChleHBvcnRzLlN1cHBvcnRlZFBhY2thZ2VzID0ge30pKTtcbi8qKlxuICogTG9hZCBmYWNlLWxhbmRtYXJrcy1kZXRlY3Rpb24uXG4gKlxuICogQHBhcmFtIHBrZyAtIFRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRvIGxvYWQsIGUuZy4gJ21lZGlhcGlwZS1mYWNlbWVzaCcuXG4gKiBAcGFyYW0gY29uZmlnIC0gYSBjb25maWd1cmF0aW9uIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqICAtIGBtYXhDb250aW51b3VzQ2hlY2tzYCBIb3cgbWFueSBmcmFtZXMgdG8gZ28gd2l0aG91dCBydW5uaW5nIHRoZSBib3VuZGluZ1xuICogYm94IGRldGVjdG9yLiBPbmx5IHJlbGV2YW50IGlmIG1heEZhY2VzID4gMS4gRGVmYXVsdHMgdG8gNS5cbiAqICAtIGBkZXRlY3Rpb25Db25maWRlbmNlYCBUaHJlc2hvbGQgZm9yIGRpc2NhcmRpbmcgYSBwcmVkaWN0aW9uLiBEZWZhdWx0cyB0b1xuICogMC45LlxuICogIC0gYG1heEZhY2VzYCBUaGUgbWF4aW11bSBudW1iZXIgb2YgZmFjZXMgZGV0ZWN0ZWQgaW4gdGhlIGlucHV0LiBTaG91bGQgYmVcbiAqIHNldCB0byB0aGUgbWluaW11bSBudW1iZXIgZm9yIHBlcmZvcm1hbmNlLiBEZWZhdWx0cyB0byAxMC5cbiAqICAtIGBpb3VUaHJlc2hvbGRgIEEgZmxvYXQgcmVwcmVzZW50aW5nIHRoZSB0aHJlc2hvbGQgZm9yIGRlY2lkaW5nIHdoZXRoZXJcbiAqIGJveGVzIG92ZXJsYXAgdG9vIG11Y2ggaW4gbm9uLW1heGltdW0gc3VwcHJlc3Npb24uIE11c3QgYmUgYmV0d2VlbiBbMCwgMV0uXG4gKiBEZWZhdWx0cyB0byAwLjMuXG4gKiAgLSBgc2NvcmVUaHJlc2hvbGRgIEEgdGhyZXNob2xkIGZvciBkZWNpZGluZyB3aGVuIHRvIHJlbW92ZSBib3hlcyBiYXNlZFxuICogb24gc2NvcmUgaW4gbm9uLW1heGltdW0gc3VwcHJlc3Npb24uIERlZmF1bHRzIHRvIDAuNzUuXG4gKiAgLSBgc2hvdWxkTG9hZElyaXNNb2RlbGAgV2hldGhlciB0byBhbHNvIGxvYWQgdGhlIGlyaXMgZGV0ZWN0aW9uIG1vZGVsLlxuICogRGVmYXVsdHMgdG8gdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gbG9hZChwa2csIGNvbmZpZykge1xuICAgIGlmIChwa2cgPT09IHZvaWQgMCkgeyBwa2cgPSBTdXBwb3J0ZWRQYWNrYWdlcy5tZWRpYXBpcGVGYWNlbWVzaDsgfVxuICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgaWYgKHBrZyA9PT0gU3VwcG9ydGVkUGFja2FnZXMubWVkaWFwaXBlRmFjZW1lc2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbWVkaWFwaXBlX2ZhY2VtZXNoXzEubG9hZChjb25maWcpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwa2cgKyBcIiBpcyBub3QgYSB2YWxpZCBwYWNrYWdlIG5hbWUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/box.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/box.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar tf = __webpack_require__(/*! @tensorflow/tfjs-core */ \"(ssr)/./node_modules/@tensorflow/tfjs-core/dist/tf-core.node.js\");\nfunction scaleBoxCoordinates(box, factor) {\n    var startPoint = [box.startPoint[0] * factor[0], box.startPoint[1] * factor[1]];\n    var endPoint = [box.endPoint[0] * factor[0], box.endPoint[1] * factor[1]];\n    return { startPoint: startPoint, endPoint: endPoint };\n}\nexports.scaleBoxCoordinates = scaleBoxCoordinates;\nfunction getBoxSize(box) {\n    return [\n        Math.abs(box.endPoint[0] - box.startPoint[0]),\n        Math.abs(box.endPoint[1] - box.startPoint[1])\n    ];\n}\nexports.getBoxSize = getBoxSize;\nfunction getBoxCenter(box) {\n    return [\n        box.startPoint[0] + (box.endPoint[0] - box.startPoint[0]) / 2,\n        box.startPoint[1] + (box.endPoint[1] - box.startPoint[1]) / 2\n    ];\n}\nexports.getBoxCenter = getBoxCenter;\nfunction cutBoxFromImageAndResize(box, image, cropSize) {\n    var h = image.shape[1];\n    var w = image.shape[2];\n    var boxes = [[\n            box.startPoint[1] / h, box.startPoint[0] / w, box.endPoint[1] / h,\n            box.endPoint[0] / w\n        ]];\n    return tf.image.cropAndResize(image, boxes, [0], cropSize, 'bilinear' /* method */, 0 /* extrapolation value */);\n}\nexports.cutBoxFromImageAndResize = cutBoxFromImageAndResize;\n/**\n * Enlarges the box by the provided factor.\n * @param box An object with startPoint and endPoint properties describing the\n * outlines of the box to be enlarged.\n * @param factor optional The enlargement factor. Defaults to 1.5\n */\nfunction enlargeBox(box, factor) {\n    if (factor === void 0) { factor = 1.5; }\n    var center = getBoxCenter(box);\n    var size = getBoxSize(box);\n    var newHalfSize = [factor * size[0] / 2, factor * size[1] / 2];\n    var startPoint = [center[0] - newHalfSize[0], center[1] - newHalfSize[1]];\n    var endPoint = [center[0] + newHalfSize[0], center[1] + newHalfSize[1]];\n    return { startPoint: startPoint, endPoint: endPoint, landmarks: box.landmarks };\n}\nexports.enlargeBox = enlargeBox;\n/**\n * Squarifies the provided box by setting its length and height equal to\n * max(length, height) while preserving its center point.\n * @param box An object with startPoint and endPoint properties describing the\n * outlines of the box to be squarified.\n */\nfunction squarifyBox(box) {\n    var centers = getBoxCenter(box);\n    var size = getBoxSize(box);\n    var maxEdge = Math.max.apply(Math, size);\n    var halfSize = maxEdge / 2;\n    var startPoint = [centers[0] - halfSize, centers[1] - halfSize];\n    var endPoint = [centers[0] + halfSize, centers[1] + halfSize];\n    return { startPoint: startPoint, endPoint: endPoint, landmarks: box.landmarks };\n}\nexports.squarifyBox = squarifyBox;\n//# sourceMappingURL=box.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3ctbW9kZWxzL2ZhY2UtbGFuZG1hcmtzLWRldGVjdGlvbi9kaXN0L21lZGlhcGlwZS1mYWNlbWVzaC9ib3guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxTQUFTLG1CQUFPLENBQUMsOEZBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktZWNvbW1lcmNlLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3ctbW9kZWxzL2ZhY2UtbGFuZG1hcmtzLWRldGVjdGlvbi9kaXN0L21lZGlhcGlwZS1mYWNlbWVzaC9ib3guanM/ZjFjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGYgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xuZnVuY3Rpb24gc2NhbGVCb3hDb29yZGluYXRlcyhib3gsIGZhY3Rvcikge1xuICAgIHZhciBzdGFydFBvaW50ID0gW2JveC5zdGFydFBvaW50WzBdICogZmFjdG9yWzBdLCBib3guc3RhcnRQb2ludFsxXSAqIGZhY3RvclsxXV07XG4gICAgdmFyIGVuZFBvaW50ID0gW2JveC5lbmRQb2ludFswXSAqIGZhY3RvclswXSwgYm94LmVuZFBvaW50WzFdICogZmFjdG9yWzFdXTtcbiAgICByZXR1cm4geyBzdGFydFBvaW50OiBzdGFydFBvaW50LCBlbmRQb2ludDogZW5kUG9pbnQgfTtcbn1cbmV4cG9ydHMuc2NhbGVCb3hDb29yZGluYXRlcyA9IHNjYWxlQm94Q29vcmRpbmF0ZXM7XG5mdW5jdGlvbiBnZXRCb3hTaXplKGJveCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIE1hdGguYWJzKGJveC5lbmRQb2ludFswXSAtIGJveC5zdGFydFBvaW50WzBdKSxcbiAgICAgICAgTWF0aC5hYnMoYm94LmVuZFBvaW50WzFdIC0gYm94LnN0YXJ0UG9pbnRbMV0pXG4gICAgXTtcbn1cbmV4cG9ydHMuZ2V0Qm94U2l6ZSA9IGdldEJveFNpemU7XG5mdW5jdGlvbiBnZXRCb3hDZW50ZXIoYm94KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYm94LnN0YXJ0UG9pbnRbMF0gKyAoYm94LmVuZFBvaW50WzBdIC0gYm94LnN0YXJ0UG9pbnRbMF0pIC8gMixcbiAgICAgICAgYm94LnN0YXJ0UG9pbnRbMV0gKyAoYm94LmVuZFBvaW50WzFdIC0gYm94LnN0YXJ0UG9pbnRbMV0pIC8gMlxuICAgIF07XG59XG5leHBvcnRzLmdldEJveENlbnRlciA9IGdldEJveENlbnRlcjtcbmZ1bmN0aW9uIGN1dEJveEZyb21JbWFnZUFuZFJlc2l6ZShib3gsIGltYWdlLCBjcm9wU2l6ZSkge1xuICAgIHZhciBoID0gaW1hZ2Uuc2hhcGVbMV07XG4gICAgdmFyIHcgPSBpbWFnZS5zaGFwZVsyXTtcbiAgICB2YXIgYm94ZXMgPSBbW1xuICAgICAgICAgICAgYm94LnN0YXJ0UG9pbnRbMV0gLyBoLCBib3guc3RhcnRQb2ludFswXSAvIHcsIGJveC5lbmRQb2ludFsxXSAvIGgsXG4gICAgICAgICAgICBib3guZW5kUG9pbnRbMF0gLyB3XG4gICAgICAgIF1dO1xuICAgIHJldHVybiB0Zi5pbWFnZS5jcm9wQW5kUmVzaXplKGltYWdlLCBib3hlcywgWzBdLCBjcm9wU2l6ZSwgJ2JpbGluZWFyJyAvKiBtZXRob2QgKi8sIDAgLyogZXh0cmFwb2xhdGlvbiB2YWx1ZSAqLyk7XG59XG5leHBvcnRzLmN1dEJveEZyb21JbWFnZUFuZFJlc2l6ZSA9IGN1dEJveEZyb21JbWFnZUFuZFJlc2l6ZTtcbi8qKlxuICogRW5sYXJnZXMgdGhlIGJveCBieSB0aGUgcHJvdmlkZWQgZmFjdG9yLlxuICogQHBhcmFtIGJveCBBbiBvYmplY3Qgd2l0aCBzdGFydFBvaW50IGFuZCBlbmRQb2ludCBwcm9wZXJ0aWVzIGRlc2NyaWJpbmcgdGhlXG4gKiBvdXRsaW5lcyBvZiB0aGUgYm94IHRvIGJlIGVubGFyZ2VkLlxuICogQHBhcmFtIGZhY3RvciBvcHRpb25hbCBUaGUgZW5sYXJnZW1lbnQgZmFjdG9yLiBEZWZhdWx0cyB0byAxLjVcbiAqL1xuZnVuY3Rpb24gZW5sYXJnZUJveChib3gsIGZhY3Rvcikge1xuICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAxLjU7IH1cbiAgICB2YXIgY2VudGVyID0gZ2V0Qm94Q2VudGVyKGJveCk7XG4gICAgdmFyIHNpemUgPSBnZXRCb3hTaXplKGJveCk7XG4gICAgdmFyIG5ld0hhbGZTaXplID0gW2ZhY3RvciAqIHNpemVbMF0gLyAyLCBmYWN0b3IgKiBzaXplWzFdIC8gMl07XG4gICAgdmFyIHN0YXJ0UG9pbnQgPSBbY2VudGVyWzBdIC0gbmV3SGFsZlNpemVbMF0sIGNlbnRlclsxXSAtIG5ld0hhbGZTaXplWzFdXTtcbiAgICB2YXIgZW5kUG9pbnQgPSBbY2VudGVyWzBdICsgbmV3SGFsZlNpemVbMF0sIGNlbnRlclsxXSArIG5ld0hhbGZTaXplWzFdXTtcbiAgICByZXR1cm4geyBzdGFydFBvaW50OiBzdGFydFBvaW50LCBlbmRQb2ludDogZW5kUG9pbnQsIGxhbmRtYXJrczogYm94LmxhbmRtYXJrcyB9O1xufVxuZXhwb3J0cy5lbmxhcmdlQm94ID0gZW5sYXJnZUJveDtcbi8qKlxuICogU3F1YXJpZmllcyB0aGUgcHJvdmlkZWQgYm94IGJ5IHNldHRpbmcgaXRzIGxlbmd0aCBhbmQgaGVpZ2h0IGVxdWFsIHRvXG4gKiBtYXgobGVuZ3RoLCBoZWlnaHQpIHdoaWxlIHByZXNlcnZpbmcgaXRzIGNlbnRlciBwb2ludC5cbiAqIEBwYXJhbSBib3ggQW4gb2JqZWN0IHdpdGggc3RhcnRQb2ludCBhbmQgZW5kUG9pbnQgcHJvcGVydGllcyBkZXNjcmliaW5nIHRoZVxuICogb3V0bGluZXMgb2YgdGhlIGJveCB0byBiZSBzcXVhcmlmaWVkLlxuICovXG5mdW5jdGlvbiBzcXVhcmlmeUJveChib3gpIHtcbiAgICB2YXIgY2VudGVycyA9IGdldEJveENlbnRlcihib3gpO1xuICAgIHZhciBzaXplID0gZ2V0Qm94U2l6ZShib3gpO1xuICAgIHZhciBtYXhFZGdlID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgc2l6ZSk7XG4gICAgdmFyIGhhbGZTaXplID0gbWF4RWRnZSAvIDI7XG4gICAgdmFyIHN0YXJ0UG9pbnQgPSBbY2VudGVyc1swXSAtIGhhbGZTaXplLCBjZW50ZXJzWzFdIC0gaGFsZlNpemVdO1xuICAgIHZhciBlbmRQb2ludCA9IFtjZW50ZXJzWzBdICsgaGFsZlNpemUsIGNlbnRlcnNbMV0gKyBoYWxmU2l6ZV07XG4gICAgcmV0dXJuIHsgc3RhcnRQb2ludDogc3RhcnRQb2ludCwgZW5kUG9pbnQ6IGVuZFBvaW50LCBsYW5kbWFya3M6IGJveC5sYW5kbWFya3MgfTtcbn1cbmV4cG9ydHMuc3F1YXJpZnlCb3ggPSBzcXVhcmlmeUJveDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJveC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/box.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/index.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/index.js ***!
  \***************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar blazeface = __webpack_require__(/*! @tensorflow-models/blazeface */ \"(ssr)/./node_modules/@tensorflow-models/blazeface/dist/index.js\");\nvar tfconv = __webpack_require__(/*! @tensorflow/tfjs-converter */ \"(ssr)/./node_modules/@tensorflow/tfjs-converter/dist/tf-converter.node.js\");\nvar tf = __webpack_require__(/*! @tensorflow/tfjs-core */ \"(ssr)/./node_modules/@tensorflow/tfjs-core/dist/tf-core.node.js\");\nvar keypoints_1 = __webpack_require__(/*! ./keypoints */ \"(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/keypoints.js\");\nvar pipeline_1 = __webpack_require__(/*! ./pipeline */ \"(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/pipeline.js\");\nvar uv_coords_1 = __webpack_require__(/*! ./uv_coords */ \"(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/uv_coords.js\");\nvar FACEMESH_GRAPHMODEL_PATH = 'https://tfhub.dev/mediapipe/tfjs-model/facemesh/1/default/1';\nvar IRIS_GRAPHMODEL_PATH = 'https://tfhub.dev/mediapipe/tfjs-model/iris/1/default/2';\nvar MESH_MODEL_INPUT_WIDTH = 192;\nvar MESH_MODEL_INPUT_HEIGHT = 192;\nvar PREDICTION_VALUES = 'MediaPipePredictionValues';\nvar PREDICTION_TENSORS = 'MediaPipePredictionTensors';\n/**\n * Load the model.\n *\n * @param options - a configuration object with the following properties:\n *  - `maxContinuousChecks` How many frames to go without running the bounding\n * box detector. Only relevant if maxFaces > 1. Defaults to 5.\n *  - `detectionConfidence` Threshold for discarding a prediction. Defaults to\n * 0.9.\n *  - `maxFaces` The maximum number of faces detected in the input. Should be\n * set to the minimum number for performance. Defaults to 10.\n *  - `iouThreshold` A float representing the threshold for deciding whether\n * boxes overlap too much in non-maximum suppression. Must be between [0, 1].\n * Defaults to 0.3.\n *  - `scoreThreshold` A threshold for deciding when to remove boxes based\n * on score in non-maximum suppression. Defaults to 0.75.\n *  - `shouldLoadIrisModel` Whether to also load the iris detection model.\n * Defaults to true.\n *  - `modelUrl` Optional param for specifying a custom facemesh model url or\n * a `tf.io.IOHandler` object.\n *  - `detectorModelUrl` Optional param for specifying a custom blazeface model\n * url or a `tf.io.IOHandler` object.\n *  - `irisModelUrl` Optional param for specifying a custom iris model url or\n * a `tf.io.IOHandler` object.\n */\nfunction load(config) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, maxContinuousChecks, _b, detectionConfidence, _c, maxFaces, _d, iouThreshold, _e, scoreThreshold, _f, shouldLoadIrisModel, modelUrl, detectorModelUrl, irisModelUrl, models, faceMesh;\n        return __generator(this, function (_g) {\n            switch (_g.label) {\n                case 0:\n                    _a = config.maxContinuousChecks, maxContinuousChecks = _a === void 0 ? 5 : _a, _b = config.detectionConfidence, detectionConfidence = _b === void 0 ? 0.9 : _b, _c = config.maxFaces, maxFaces = _c === void 0 ? 10 : _c, _d = config.iouThreshold, iouThreshold = _d === void 0 ? 0.3 : _d, _e = config.scoreThreshold, scoreThreshold = _e === void 0 ? 0.75 : _e, _f = config.shouldLoadIrisModel, shouldLoadIrisModel = _f === void 0 ? true : _f, modelUrl = config.modelUrl, detectorModelUrl = config.detectorModelUrl, irisModelUrl = config.irisModelUrl;\n                    if (!shouldLoadIrisModel) return [3 /*break*/, 2];\n                    return [4 /*yield*/, Promise.all([\n                            loadDetectorModel(detectorModelUrl, maxFaces, iouThreshold, scoreThreshold),\n                            loadMeshModel(modelUrl),\n                            loadIrisModel(irisModelUrl)\n                        ])];\n                case 1:\n                    models = _g.sent();\n                    return [3 /*break*/, 4];\n                case 2: return [4 /*yield*/, Promise.all([\n                        loadDetectorModel(detectorModelUrl, maxFaces, iouThreshold, scoreThreshold),\n                        loadMeshModel(modelUrl)\n                    ])];\n                case 3:\n                    models = _g.sent();\n                    _g.label = 4;\n                case 4:\n                    faceMesh = new FaceMesh(models[0], models[1], maxContinuousChecks, detectionConfidence, maxFaces, shouldLoadIrisModel ? models[2] : null);\n                    return [2 /*return*/, faceMesh];\n            }\n        });\n    });\n}\nexports.load = load;\nfunction loadDetectorModel(modelUrl, maxFaces, iouThreshold, scoreThreshold) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, blazeface.load({ modelUrl: modelUrl, maxFaces: maxFaces, iouThreshold: iouThreshold, scoreThreshold: scoreThreshold })];\n        });\n    });\n}\nfunction loadMeshModel(modelUrl) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            if (modelUrl != null) {\n                return [2 /*return*/, tfconv.loadGraphModel(modelUrl)];\n            }\n            return [2 /*return*/, tfconv.loadGraphModel(FACEMESH_GRAPHMODEL_PATH, { fromTFHub: true })];\n        });\n    });\n}\nfunction loadIrisModel(modelUrl) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            if (modelUrl != null) {\n                return [2 /*return*/, tfconv.loadGraphModel(modelUrl)];\n            }\n            return [2 /*return*/, tfconv.loadGraphModel(IRIS_GRAPHMODEL_PATH, { fromTFHub: true })];\n        });\n    });\n}\nfunction getInputTensorDimensions(input) {\n    return input instanceof tf.Tensor ? [input.shape[0], input.shape[1]] :\n        [input.height, input.width];\n}\nfunction flipFaceHorizontal(face, imageWidth) {\n    if (face.mesh instanceof tf.Tensor) {\n        var _a = tf.tidy(function () {\n            var subtractBasis = tf.tensor1d([imageWidth - 1, 0, 0]);\n            var multiplyBasis = tf.tensor1d([1, -1, 1]);\n            return tf.tidy(function () {\n                return [\n                    tf.concat([\n                        tf.sub(imageWidth - 1, tf.slice(face.boundingBox.topLeft, 0, 1)),\n                        tf.slice(face.boundingBox.topLeft, 1, 1)\n                    ]),\n                    tf.concat([\n                        tf.sub(imageWidth - 1, tf.slice(face.boundingBox.bottomRight, 0, 1)),\n                        tf.slice(face.boundingBox.bottomRight, 1, 1)\n                    ]),\n                    tf.mul(tf.sub(subtractBasis, face.mesh), multiplyBasis),\n                    tf.mul(tf.sub(subtractBasis, face.scaledMesh), multiplyBasis)\n                ];\n            });\n        }), topLeft = _a[0], bottomRight = _a[1], mesh = _a[2], scaledMesh = _a[3];\n        return Object.assign({}, face, { boundingBox: { topLeft: topLeft, bottomRight: bottomRight }, mesh: mesh, scaledMesh: scaledMesh });\n    }\n    return Object.assign({}, face, {\n        boundingBox: {\n            topLeft: [\n                imageWidth - 1 - face.boundingBox.topLeft[0],\n                face.boundingBox.topLeft[1]\n            ],\n            bottomRight: [\n                imageWidth - 1 - face.boundingBox.bottomRight[0],\n                face.boundingBox.bottomRight[1]\n            ]\n        },\n        mesh: (face.mesh).map(function (coord) {\n            var flippedCoord = coord.slice(0);\n            flippedCoord[0] = imageWidth - 1 - coord[0];\n            return flippedCoord;\n        }),\n        scaledMesh: face.scaledMesh.map(function (coord) {\n            var flippedCoord = coord.slice(0);\n            flippedCoord[0] = imageWidth - 1 - coord[0];\n            return flippedCoord;\n        })\n    });\n}\nvar FaceMesh = /** @class */ (function () {\n    function FaceMesh(blazeFace, blazeMeshModel, maxContinuousChecks, detectionConfidence, maxFaces, irisModel) {\n        this.kind = 'MediaPipeFaceMesh';\n        this.pipeline = new pipeline_1.Pipeline(blazeFace, blazeMeshModel, MESH_MODEL_INPUT_WIDTH, MESH_MODEL_INPUT_HEIGHT, maxContinuousChecks, maxFaces, irisModel);\n        this.detectionConfidence = detectionConfidence;\n    }\n    FaceMesh.getAnnotations = function () {\n        return keypoints_1.MESH_ANNOTATIONS;\n    };\n    /**\n     * Returns an array of UV coordinates for the 468 facial keypoint vertices in\n     * mesh_map.jpg. Can be used to map textures to the facial mesh.\n     */\n    FaceMesh.getUVCoords = function () {\n        return uv_coords_1.UV_COORDS;\n    };\n    /**\n     * Returns an array of faces in an image.\n     *\n     * @param input The image to classify. Can be a tensor, DOM element image,\n     * video, or canvas.\n     * @param returnTensors (defaults to `false`) Whether to return tensors as\n     * opposed to values.\n     * @param flipHorizontal Whether to flip/mirror the facial keypoints\n     * horizontally. Should be true for videos that are flipped by default (e.g.\n     * webcams).\n     * @param predictIrises\n     *\n     * @return An array of AnnotatedPrediction objects.\n     */\n    FaceMesh.prototype.estimateFaces = function (config) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, returnTensors, _b, flipHorizontal, _c, predictIrises, input, _d, width, image, predictions, savedWebglPackDepthwiseConvFlag;\n            var _this = this;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        _a = config.returnTensors, returnTensors = _a === void 0 ? false : _a, _b = config.flipHorizontal, flipHorizontal = _b === void 0 ? false : _b, _c = config.predictIrises, predictIrises = _c === void 0 ? true : _c;\n                        input = config.input;\n                        if (predictIrises && this.pipeline.irisModel == null) {\n                            throw new Error('The iris model was not loaded as part of facemesh. ' +\n                                'Please initialize the model with ' +\n                                'facemesh.load({shouldLoadIrisModel: true}).');\n                        }\n                        _d = getInputTensorDimensions(input), width = _d[1];\n                        image = tf.tidy(function () {\n                            if (!(input instanceof tf.Tensor)) {\n                                input = tf.browser.fromPixels(input);\n                            }\n                            return tf.expandDims(tf.cast(input, 'float32'), 0);\n                        });\n                        if (!(tf.getBackend() === 'webgl')) return [3 /*break*/, 2];\n                        savedWebglPackDepthwiseConvFlag = tf.env().get('WEBGL_PACK_DEPTHWISECONV');\n                        tf.env().set('WEBGL_PACK_DEPTHWISECONV', true);\n                        return [4 /*yield*/, this.pipeline.predict(image, predictIrises)];\n                    case 1:\n                        predictions = _e.sent();\n                        tf.env().set('WEBGL_PACK_DEPTHWISECONV', savedWebglPackDepthwiseConvFlag);\n                        return [3 /*break*/, 4];\n                    case 2: return [4 /*yield*/, this.pipeline.predict(image, predictIrises)];\n                    case 3:\n                        predictions = _e.sent();\n                        _e.label = 4;\n                    case 4:\n                        image.dispose();\n                        if (predictions != null && predictions.length > 0) {\n                            return [2 /*return*/, Promise.all(predictions.map(function (prediction, i) { return __awaiter(_this, void 0, void 0, function () {\n                                    var coords, scaledCoords, box, flag, tensorsToRead, tensorValues, flagValue, annotatedPrediction_1, _a, coordsArr, coordsArrScaled, annotatedPrediction, annotations, key;\n                                    var _this = this;\n                                    return __generator(this, function (_b) {\n                                        switch (_b.label) {\n                                            case 0:\n                                                coords = prediction.coords, scaledCoords = prediction.scaledCoords, box = prediction.box, flag = prediction.flag;\n                                                tensorsToRead = [flag];\n                                                if (!returnTensors) {\n                                                    tensorsToRead = tensorsToRead.concat([coords, scaledCoords]);\n                                                }\n                                                return [4 /*yield*/, Promise.all(tensorsToRead.map(function (d) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {\n                                                        return [2 /*return*/, d.array()];\n                                                    }); }); }))];\n                                            case 1:\n                                                tensorValues = _b.sent();\n                                                flagValue = tensorValues[0];\n                                                flag.dispose();\n                                                if (flagValue < this.detectionConfidence) {\n                                                    this.pipeline.clearRegionOfInterest(i);\n                                                }\n                                                if (returnTensors) {\n                                                    annotatedPrediction_1 = {\n                                                        kind: PREDICTION_TENSORS,\n                                                        faceInViewConfidence: flagValue,\n                                                        mesh: coords,\n                                                        scaledMesh: scaledCoords,\n                                                        boundingBox: {\n                                                            topLeft: tf.tensor1d(box.startPoint),\n                                                            bottomRight: tf.tensor1d(box.endPoint)\n                                                        }\n                                                    };\n                                                    if (flipHorizontal) {\n                                                        return [2 /*return*/, flipFaceHorizontal(annotatedPrediction_1, width)];\n                                                    }\n                                                    return [2 /*return*/, annotatedPrediction_1];\n                                                }\n                                                _a = tensorValues.slice(1), coordsArr = _a[0], coordsArrScaled = _a[1];\n                                                scaledCoords.dispose();\n                                                coords.dispose();\n                                                annotatedPrediction = {\n                                                    kind: PREDICTION_VALUES,\n                                                    faceInViewConfidence: flagValue,\n                                                    boundingBox: { topLeft: box.startPoint, bottomRight: box.endPoint },\n                                                    mesh: coordsArr,\n                                                    scaledMesh: coordsArrScaled\n                                                };\n                                                if (flipHorizontal) {\n                                                    annotatedPrediction =\n                                                        flipFaceHorizontal(annotatedPrediction, width);\n                                                }\n                                                annotations = {};\n                                                for (key in keypoints_1.MESH_ANNOTATIONS) {\n                                                    if (predictIrises || key.includes('Iris') === false) {\n                                                        annotations[key] = keypoints_1.MESH_ANNOTATIONS[key].map(function (index) { return annotatedPrediction.scaledMesh[index]; });\n                                                    }\n                                                }\n                                                annotatedPrediction['annotations'] = annotations;\n                                                return [2 /*return*/, annotatedPrediction];\n                                        }\n                                    });\n                                }); }))];\n                        }\n                        return [2 /*return*/, []];\n                }\n            });\n        });\n    };\n    return FaceMesh;\n}());\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3ctbW9kZWxzL2ZhY2UtbGFuZG1hcmtzLWRldGVjdGlvbi9kaXN0L21lZGlhcGlwZS1mYWNlbWVzaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQyxpRUFBaUUsd0JBQXdCO0FBQ3pIO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLHFHQUE4QjtBQUN0RCxhQUFhLG1CQUFPLENBQUMsNkdBQTRCO0FBQ2pELFNBQVMsbUJBQU8sQ0FBQyw4RkFBdUI7QUFDeEMsa0JBQWtCLG1CQUFPLENBQUMsMEhBQWE7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsd0hBQVk7QUFDckMsa0JBQWtCLG1CQUFPLENBQUMsMEhBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsb0dBQW9HO0FBQ3ZKLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsaUJBQWlCO0FBQ3JHLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsK0JBQStCLFVBQVUsZUFBZSw0Q0FBNEMsc0NBQXNDO0FBQzFJO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSCxzREFBc0Q7QUFDeEs7QUFDQSxxREFBcUQsSUFBSSxJQUFJO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsb0RBQW9EO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0lBQW9JLCtDQUErQztBQUNuTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWVjb21tZXJjZS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93LW1vZGVscy9mYWNlLWxhbmRtYXJrcy1kZXRlY3Rpb24vZGlzdC9tZWRpYXBpcGUtZmFjZW1lc2gvaW5kZXguanM/M2I4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJsYXplZmFjZSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy1tb2RlbHMvYmxhemVmYWNlXCIpO1xudmFyIHRmY29udiA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlclwiKTtcbnZhciB0ZiA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIga2V5cG9pbnRzXzEgPSByZXF1aXJlKFwiLi9rZXlwb2ludHNcIik7XG52YXIgcGlwZWxpbmVfMSA9IHJlcXVpcmUoXCIuL3BpcGVsaW5lXCIpO1xudmFyIHV2X2Nvb3Jkc18xID0gcmVxdWlyZShcIi4vdXZfY29vcmRzXCIpO1xudmFyIEZBQ0VNRVNIX0dSQVBITU9ERUxfUEFUSCA9ICdodHRwczovL3RmaHViLmRldi9tZWRpYXBpcGUvdGZqcy1tb2RlbC9mYWNlbWVzaC8xL2RlZmF1bHQvMSc7XG52YXIgSVJJU19HUkFQSE1PREVMX1BBVEggPSAnaHR0cHM6Ly90Zmh1Yi5kZXYvbWVkaWFwaXBlL3RmanMtbW9kZWwvaXJpcy8xL2RlZmF1bHQvMic7XG52YXIgTUVTSF9NT0RFTF9JTlBVVF9XSURUSCA9IDE5MjtcbnZhciBNRVNIX01PREVMX0lOUFVUX0hFSUdIVCA9IDE5MjtcbnZhciBQUkVESUNUSU9OX1ZBTFVFUyA9ICdNZWRpYVBpcGVQcmVkaWN0aW9uVmFsdWVzJztcbnZhciBQUkVESUNUSU9OX1RFTlNPUlMgPSAnTWVkaWFQaXBlUHJlZGljdGlvblRlbnNvcnMnO1xuLyoqXG4gKiBMb2FkIHRoZSBtb2RlbC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIGEgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiAgLSBgbWF4Q29udGludW91c0NoZWNrc2AgSG93IG1hbnkgZnJhbWVzIHRvIGdvIHdpdGhvdXQgcnVubmluZyB0aGUgYm91bmRpbmdcbiAqIGJveCBkZXRlY3Rvci4gT25seSByZWxldmFudCBpZiBtYXhGYWNlcyA+IDEuIERlZmF1bHRzIHRvIDUuXG4gKiAgLSBgZGV0ZWN0aW9uQ29uZmlkZW5jZWAgVGhyZXNob2xkIGZvciBkaXNjYXJkaW5nIGEgcHJlZGljdGlvbi4gRGVmYXVsdHMgdG9cbiAqIDAuOS5cbiAqICAtIGBtYXhGYWNlc2AgVGhlIG1heGltdW0gbnVtYmVyIG9mIGZhY2VzIGRldGVjdGVkIGluIHRoZSBpbnB1dC4gU2hvdWxkIGJlXG4gKiBzZXQgdG8gdGhlIG1pbmltdW0gbnVtYmVyIGZvciBwZXJmb3JtYW5jZS4gRGVmYXVsdHMgdG8gMTAuXG4gKiAgLSBgaW91VGhyZXNob2xkYCBBIGZsb2F0IHJlcHJlc2VudGluZyB0aGUgdGhyZXNob2xkIGZvciBkZWNpZGluZyB3aGV0aGVyXG4gKiBib3hlcyBvdmVybGFwIHRvbyBtdWNoIGluIG5vbi1tYXhpbXVtIHN1cHByZXNzaW9uLiBNdXN0IGJlIGJldHdlZW4gWzAsIDFdLlxuICogRGVmYXVsdHMgdG8gMC4zLlxuICogIC0gYHNjb3JlVGhyZXNob2xkYCBBIHRocmVzaG9sZCBmb3IgZGVjaWRpbmcgd2hlbiB0byByZW1vdmUgYm94ZXMgYmFzZWRcbiAqIG9uIHNjb3JlIGluIG5vbi1tYXhpbXVtIHN1cHByZXNzaW9uLiBEZWZhdWx0cyB0byAwLjc1LlxuICogIC0gYHNob3VsZExvYWRJcmlzTW9kZWxgIFdoZXRoZXIgdG8gYWxzbyBsb2FkIHRoZSBpcmlzIGRldGVjdGlvbiBtb2RlbC5cbiAqIERlZmF1bHRzIHRvIHRydWUuXG4gKiAgLSBgbW9kZWxVcmxgIE9wdGlvbmFsIHBhcmFtIGZvciBzcGVjaWZ5aW5nIGEgY3VzdG9tIGZhY2VtZXNoIG1vZGVsIHVybCBvclxuICogYSBgdGYuaW8uSU9IYW5kbGVyYCBvYmplY3QuXG4gKiAgLSBgZGV0ZWN0b3JNb2RlbFVybGAgT3B0aW9uYWwgcGFyYW0gZm9yIHNwZWNpZnlpbmcgYSBjdXN0b20gYmxhemVmYWNlIG1vZGVsXG4gKiB1cmwgb3IgYSBgdGYuaW8uSU9IYW5kbGVyYCBvYmplY3QuXG4gKiAgLSBgaXJpc01vZGVsVXJsYCBPcHRpb25hbCBwYXJhbSBmb3Igc3BlY2lmeWluZyBhIGN1c3RvbSBpcmlzIG1vZGVsIHVybCBvclxuICogYSBgdGYuaW8uSU9IYW5kbGVyYCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGxvYWQoY29uZmlnKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIG1heENvbnRpbnVvdXNDaGVja3MsIF9iLCBkZXRlY3Rpb25Db25maWRlbmNlLCBfYywgbWF4RmFjZXMsIF9kLCBpb3VUaHJlc2hvbGQsIF9lLCBzY29yZVRocmVzaG9sZCwgX2YsIHNob3VsZExvYWRJcmlzTW9kZWwsIG1vZGVsVXJsLCBkZXRlY3Rvck1vZGVsVXJsLCBpcmlzTW9kZWxVcmwsIG1vZGVscywgZmFjZU1lc2g7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2cpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2cubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9hID0gY29uZmlnLm1heENvbnRpbnVvdXNDaGVja3MsIG1heENvbnRpbnVvdXNDaGVja3MgPSBfYSA9PT0gdm9pZCAwID8gNSA6IF9hLCBfYiA9IGNvbmZpZy5kZXRlY3Rpb25Db25maWRlbmNlLCBkZXRlY3Rpb25Db25maWRlbmNlID0gX2IgPT09IHZvaWQgMCA/IDAuOSA6IF9iLCBfYyA9IGNvbmZpZy5tYXhGYWNlcywgbWF4RmFjZXMgPSBfYyA9PT0gdm9pZCAwID8gMTAgOiBfYywgX2QgPSBjb25maWcuaW91VGhyZXNob2xkLCBpb3VUaHJlc2hvbGQgPSBfZCA9PT0gdm9pZCAwID8gMC4zIDogX2QsIF9lID0gY29uZmlnLnNjb3JlVGhyZXNob2xkLCBzY29yZVRocmVzaG9sZCA9IF9lID09PSB2b2lkIDAgPyAwLjc1IDogX2UsIF9mID0gY29uZmlnLnNob3VsZExvYWRJcmlzTW9kZWwsIHNob3VsZExvYWRJcmlzTW9kZWwgPSBfZiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9mLCBtb2RlbFVybCA9IGNvbmZpZy5tb2RlbFVybCwgZGV0ZWN0b3JNb2RlbFVybCA9IGNvbmZpZy5kZXRlY3Rvck1vZGVsVXJsLCBpcmlzTW9kZWxVcmwgPSBjb25maWcuaXJpc01vZGVsVXJsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZExvYWRJcmlzTW9kZWwpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZERldGVjdG9yTW9kZWwoZGV0ZWN0b3JNb2RlbFVybCwgbWF4RmFjZXMsIGlvdVRocmVzaG9sZCwgc2NvcmVUaHJlc2hvbGQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRNZXNoTW9kZWwobW9kZWxVcmwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRJcmlzTW9kZWwoaXJpc01vZGVsVXJsKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxzID0gX2cuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWREZXRlY3Rvck1vZGVsKGRldGVjdG9yTW9kZWxVcmwsIG1heEZhY2VzLCBpb3VUaHJlc2hvbGQsIHNjb3JlVGhyZXNob2xkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRNZXNoTW9kZWwobW9kZWxVcmwpXG4gICAgICAgICAgICAgICAgICAgIF0pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1vZGVscyA9IF9nLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2cubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgZmFjZU1lc2ggPSBuZXcgRmFjZU1lc2gobW9kZWxzWzBdLCBtb2RlbHNbMV0sIG1heENvbnRpbnVvdXNDaGVja3MsIGRldGVjdGlvbkNvbmZpZGVuY2UsIG1heEZhY2VzLCBzaG91bGRMb2FkSXJpc01vZGVsID8gbW9kZWxzWzJdIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmYWNlTWVzaF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmZ1bmN0aW9uIGxvYWREZXRlY3Rvck1vZGVsKG1vZGVsVXJsLCBtYXhGYWNlcywgaW91VGhyZXNob2xkLCBzY29yZVRocmVzaG9sZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJsYXplZmFjZS5sb2FkKHsgbW9kZWxVcmw6IG1vZGVsVXJsLCBtYXhGYWNlczogbWF4RmFjZXMsIGlvdVRocmVzaG9sZDogaW91VGhyZXNob2xkLCBzY29yZVRocmVzaG9sZDogc2NvcmVUaHJlc2hvbGQgfSldO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGxvYWRNZXNoTW9kZWwobW9kZWxVcmwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIGlmIChtb2RlbFVybCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRmY29udi5sb2FkR3JhcGhNb2RlbChtb2RlbFVybCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRmY29udi5sb2FkR3JhcGhNb2RlbChGQUNFTUVTSF9HUkFQSE1PREVMX1BBVEgsIHsgZnJvbVRGSHViOiB0cnVlIH0pXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBsb2FkSXJpc01vZGVsKG1vZGVsVXJsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBpZiAobW9kZWxVcmwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0ZmNvbnYubG9hZEdyYXBoTW9kZWwobW9kZWxVcmwpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0ZmNvbnYubG9hZEdyYXBoTW9kZWwoSVJJU19HUkFQSE1PREVMX1BBVEgsIHsgZnJvbVRGSHViOiB0cnVlIH0pXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRJbnB1dFRlbnNvckRpbWVuc2lvbnMoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiB0Zi5UZW5zb3IgPyBbaW5wdXQuc2hhcGVbMF0sIGlucHV0LnNoYXBlWzFdXSA6XG4gICAgICAgIFtpbnB1dC5oZWlnaHQsIGlucHV0LndpZHRoXTtcbn1cbmZ1bmN0aW9uIGZsaXBGYWNlSG9yaXpvbnRhbChmYWNlLCBpbWFnZVdpZHRoKSB7XG4gICAgaWYgKGZhY2UubWVzaCBpbnN0YW5jZW9mIHRmLlRlbnNvcikge1xuICAgICAgICB2YXIgX2EgPSB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdWJ0cmFjdEJhc2lzID0gdGYudGVuc29yMWQoW2ltYWdlV2lkdGggLSAxLCAwLCAwXSk7XG4gICAgICAgICAgICB2YXIgbXVsdGlwbHlCYXNpcyA9IHRmLnRlbnNvcjFkKFsxLCAtMSwgMV0pO1xuICAgICAgICAgICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRmLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgICAgICB0Zi5zdWIoaW1hZ2VXaWR0aCAtIDEsIHRmLnNsaWNlKGZhY2UuYm91bmRpbmdCb3gudG9wTGVmdCwgMCwgMSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGYuc2xpY2UoZmFjZS5ib3VuZGluZ0JveC50b3BMZWZ0LCAxLCAxKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgdGYuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRmLnN1YihpbWFnZVdpZHRoIC0gMSwgdGYuc2xpY2UoZmFjZS5ib3VuZGluZ0JveC5ib3R0b21SaWdodCwgMCwgMSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGYuc2xpY2UoZmFjZS5ib3VuZGluZ0JveC5ib3R0b21SaWdodCwgMSwgMSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIHRmLm11bCh0Zi5zdWIoc3VidHJhY3RCYXNpcywgZmFjZS5tZXNoKSwgbXVsdGlwbHlCYXNpcyksXG4gICAgICAgICAgICAgICAgICAgIHRmLm11bCh0Zi5zdWIoc3VidHJhY3RCYXNpcywgZmFjZS5zY2FsZWRNZXNoKSwgbXVsdGlwbHlCYXNpcylcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLCB0b3BMZWZ0ID0gX2FbMF0sIGJvdHRvbVJpZ2h0ID0gX2FbMV0sIG1lc2ggPSBfYVsyXSwgc2NhbGVkTWVzaCA9IF9hWzNdO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZmFjZSwgeyBib3VuZGluZ0JveDogeyB0b3BMZWZ0OiB0b3BMZWZ0LCBib3R0b21SaWdodDogYm90dG9tUmlnaHQgfSwgbWVzaDogbWVzaCwgc2NhbGVkTWVzaDogc2NhbGVkTWVzaCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGZhY2UsIHtcbiAgICAgICAgYm91bmRpbmdCb3g6IHtcbiAgICAgICAgICAgIHRvcExlZnQ6IFtcbiAgICAgICAgICAgICAgICBpbWFnZVdpZHRoIC0gMSAtIGZhY2UuYm91bmRpbmdCb3gudG9wTGVmdFswXSxcbiAgICAgICAgICAgICAgICBmYWNlLmJvdW5kaW5nQm94LnRvcExlZnRbMV1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBib3R0b21SaWdodDogW1xuICAgICAgICAgICAgICAgIGltYWdlV2lkdGggLSAxIC0gZmFjZS5ib3VuZGluZ0JveC5ib3R0b21SaWdodFswXSxcbiAgICAgICAgICAgICAgICBmYWNlLmJvdW5kaW5nQm94LmJvdHRvbVJpZ2h0WzFdXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIG1lc2g6IChmYWNlLm1lc2gpLm1hcChmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgICAgIHZhciBmbGlwcGVkQ29vcmQgPSBjb29yZC5zbGljZSgwKTtcbiAgICAgICAgICAgIGZsaXBwZWRDb29yZFswXSA9IGltYWdlV2lkdGggLSAxIC0gY29vcmRbMF07XG4gICAgICAgICAgICByZXR1cm4gZmxpcHBlZENvb3JkO1xuICAgICAgICB9KSxcbiAgICAgICAgc2NhbGVkTWVzaDogZmFjZS5zY2FsZWRNZXNoLm1hcChmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgICAgIHZhciBmbGlwcGVkQ29vcmQgPSBjb29yZC5zbGljZSgwKTtcbiAgICAgICAgICAgIGZsaXBwZWRDb29yZFswXSA9IGltYWdlV2lkdGggLSAxIC0gY29vcmRbMF07XG4gICAgICAgICAgICByZXR1cm4gZmxpcHBlZENvb3JkO1xuICAgICAgICB9KVxuICAgIH0pO1xufVxudmFyIEZhY2VNZXNoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZhY2VNZXNoKGJsYXplRmFjZSwgYmxhemVNZXNoTW9kZWwsIG1heENvbnRpbnVvdXNDaGVja3MsIGRldGVjdGlvbkNvbmZpZGVuY2UsIG1heEZhY2VzLCBpcmlzTW9kZWwpIHtcbiAgICAgICAgdGhpcy5raW5kID0gJ01lZGlhUGlwZUZhY2VNZXNoJztcbiAgICAgICAgdGhpcy5waXBlbGluZSA9IG5ldyBwaXBlbGluZV8xLlBpcGVsaW5lKGJsYXplRmFjZSwgYmxhemVNZXNoTW9kZWwsIE1FU0hfTU9ERUxfSU5QVVRfV0lEVEgsIE1FU0hfTU9ERUxfSU5QVVRfSEVJR0hULCBtYXhDb250aW51b3VzQ2hlY2tzLCBtYXhGYWNlcywgaXJpc01vZGVsKTtcbiAgICAgICAgdGhpcy5kZXRlY3Rpb25Db25maWRlbmNlID0gZGV0ZWN0aW9uQ29uZmlkZW5jZTtcbiAgICB9XG4gICAgRmFjZU1lc2guZ2V0QW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBrZXlwb2ludHNfMS5NRVNIX0FOTk9UQVRJT05TO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBVViBjb29yZGluYXRlcyBmb3IgdGhlIDQ2OCBmYWNpYWwga2V5cG9pbnQgdmVydGljZXMgaW5cbiAgICAgKiBtZXNoX21hcC5qcGcuIENhbiBiZSB1c2VkIHRvIG1hcCB0ZXh0dXJlcyB0byB0aGUgZmFjaWFsIG1lc2guXG4gICAgICovXG4gICAgRmFjZU1lc2guZ2V0VVZDb29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1dl9jb29yZHNfMS5VVl9DT09SRFM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGZhY2VzIGluIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbWFnZSB0byBjbGFzc2lmeS4gQ2FuIGJlIGEgdGVuc29yLCBET00gZWxlbWVudCBpbWFnZSxcbiAgICAgKiB2aWRlbywgb3IgY2FudmFzLlxuICAgICAqIEBwYXJhbSByZXR1cm5UZW5zb3JzIChkZWZhdWx0cyB0byBgZmFsc2VgKSBXaGV0aGVyIHRvIHJldHVybiB0ZW5zb3JzIGFzXG4gICAgICogb3Bwb3NlZCB0byB2YWx1ZXMuXG4gICAgICogQHBhcmFtIGZsaXBIb3Jpem9udGFsIFdoZXRoZXIgdG8gZmxpcC9taXJyb3IgdGhlIGZhY2lhbCBrZXlwb2ludHNcbiAgICAgKiBob3Jpem9udGFsbHkuIFNob3VsZCBiZSB0cnVlIGZvciB2aWRlb3MgdGhhdCBhcmUgZmxpcHBlZCBieSBkZWZhdWx0IChlLmcuXG4gICAgICogd2ViY2FtcykuXG4gICAgICogQHBhcmFtIHByZWRpY3RJcmlzZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gQW4gYXJyYXkgb2YgQW5ub3RhdGVkUHJlZGljdGlvbiBvYmplY3RzLlxuICAgICAqL1xuICAgIEZhY2VNZXNoLnByb3RvdHlwZS5lc3RpbWF0ZUZhY2VzID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIHJldHVyblRlbnNvcnMsIF9iLCBmbGlwSG9yaXpvbnRhbCwgX2MsIHByZWRpY3RJcmlzZXMsIGlucHV0LCBfZCwgd2lkdGgsIGltYWdlLCBwcmVkaWN0aW9ucywgc2F2ZWRXZWJnbFBhY2tEZXB0aHdpc2VDb252RmxhZztcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IGNvbmZpZy5yZXR1cm5UZW5zb3JzLCByZXR1cm5UZW5zb3JzID0gX2EgPT09IHZvaWQgMCA/IGZhbHNlIDogX2EsIF9iID0gY29uZmlnLmZsaXBIb3Jpem9udGFsLCBmbGlwSG9yaXpvbnRhbCA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCBfYyA9IGNvbmZpZy5wcmVkaWN0SXJpc2VzLCBwcmVkaWN0SXJpc2VzID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0ID0gY29uZmlnLmlucHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWRpY3RJcmlzZXMgJiYgdGhpcy5waXBlbGluZS5pcmlzTW9kZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGlyaXMgbW9kZWwgd2FzIG5vdCBsb2FkZWQgYXMgcGFydCBvZiBmYWNlbWVzaC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdQbGVhc2UgaW5pdGlhbGl6ZSB0aGUgbW9kZWwgd2l0aCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZhY2VtZXNoLmxvYWQoe3Nob3VsZExvYWRJcmlzTW9kZWw6IHRydWV9KS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gZ2V0SW5wdXRUZW5zb3JEaW1lbnNpb25zKGlucHV0KSwgd2lkdGggPSBfZFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlID0gdGYudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiB0Zi5UZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0ID0gdGYuYnJvd3Nlci5mcm9tUGl4ZWxzKGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRmLmV4cGFuZERpbXModGYuY2FzdChpbnB1dCwgJ2Zsb2F0MzInKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRmLmdldEJhY2tlbmQoKSA9PT0gJ3dlYmdsJykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZWRXZWJnbFBhY2tEZXB0aHdpc2VDb252RmxhZyA9IHRmLmVudigpLmdldCgnV0VCR0xfUEFDS19ERVBUSFdJU0VDT05WJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0Zi5lbnYoKS5zZXQoJ1dFQkdMX1BBQ0tfREVQVEhXSVNFQ09OVicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5waXBlbGluZS5wcmVkaWN0KGltYWdlLCBwcmVkaWN0SXJpc2VzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWRpY3Rpb25zID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGYuZW52KCkuc2V0KCdXRUJHTF9QQUNLX0RFUFRIV0lTRUNPTlYnLCBzYXZlZFdlYmdsUGFja0RlcHRod2lzZUNvbnZGbGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGlwZWxpbmUucHJlZGljdChpbWFnZSwgcHJlZGljdElyaXNlcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWN0aW9ucyA9IF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWRpY3Rpb25zICE9IG51bGwgJiYgcHJlZGljdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBQcm9taXNlLmFsbChwcmVkaWN0aW9ucy5tYXAoZnVuY3Rpb24gKHByZWRpY3Rpb24sIGkpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29yZHMsIHNjYWxlZENvb3JkcywgYm94LCBmbGFnLCB0ZW5zb3JzVG9SZWFkLCB0ZW5zb3JWYWx1ZXMsIGZsYWdWYWx1ZSwgYW5ub3RhdGVkUHJlZGljdGlvbl8xLCBfYSwgY29vcmRzQXJyLCBjb29yZHNBcnJTY2FsZWQsIGFubm90YXRlZFByZWRpY3Rpb24sIGFubm90YXRpb25zLCBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRzID0gcHJlZGljdGlvbi5jb29yZHMsIHNjYWxlZENvb3JkcyA9IHByZWRpY3Rpb24uc2NhbGVkQ29vcmRzLCBib3ggPSBwcmVkaWN0aW9uLmJveCwgZmxhZyA9IHByZWRpY3Rpb24uZmxhZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvcnNUb1JlYWQgPSBbZmxhZ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJldHVyblRlbnNvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JzVG9SZWFkID0gdGVuc29yc1RvUmVhZC5jb25jYXQoW2Nvb3Jkcywgc2NhbGVkQ29vcmRzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbCh0ZW5zb3JzVG9SZWFkLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkLmFycmF5KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KTsgfSkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yVmFsdWVzID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ1ZhbHVlID0gdGVuc29yVmFsdWVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ1ZhbHVlIDwgdGhpcy5kZXRlY3Rpb25Db25maWRlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5waXBlbGluZS5jbGVhclJlZ2lvbk9mSW50ZXJlc3QoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVGVuc29ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRlZFByZWRpY3Rpb25fMSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogUFJFRElDVElPTl9URU5TT1JTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlSW5WaWV3Q29uZmlkZW5jZTogZmxhZ1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNoOiBjb29yZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlZE1lc2g6IHNjYWxlZENvb3JkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRpbmdCb3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcExlZnQ6IHRmLnRlbnNvcjFkKGJveC5zdGFydFBvaW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0OiB0Zi50ZW5zb3IxZChib3guZW5kUG9pbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbGlwSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmxpcEZhY2VIb3Jpem9udGFsKGFubm90YXRlZFByZWRpY3Rpb25fMSwgd2lkdGgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGFubm90YXRlZFByZWRpY3Rpb25fMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRlbnNvclZhbHVlcy5zbGljZSgxKSwgY29vcmRzQXJyID0gX2FbMF0sIGNvb3Jkc0FyclNjYWxlZCA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkQ29vcmRzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3Jkcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZWRQcmVkaWN0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFBSRURJQ1RJT05fVkFMVUVTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VJblZpZXdDb25maWRlbmNlOiBmbGFnVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRpbmdCb3g6IHsgdG9wTGVmdDogYm94LnN0YXJ0UG9pbnQsIGJvdHRvbVJpZ2h0OiBib3guZW5kUG9pbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNoOiBjb29yZHNBcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkTWVzaDogY29vcmRzQXJyU2NhbGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZsaXBIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVkUHJlZGljdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsaXBGYWNlSG9yaXpvbnRhbChhbm5vdGF0ZWRQcmVkaWN0aW9uLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4ga2V5cG9pbnRzXzEuTUVTSF9BTk5PVEFUSU9OUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWN0SXJpc2VzIHx8IGtleS5pbmNsdWRlcygnSXJpcycpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uc1trZXldID0ga2V5cG9pbnRzXzEuTUVTSF9BTk5PVEFUSU9OU1trZXldLm1hcChmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIGFubm90YXRlZFByZWRpY3Rpb24uc2NhbGVkTWVzaFtpbmRleF07IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRlZFByZWRpY3Rpb25bJ2Fubm90YXRpb25zJ10gPSBhbm5vdGF0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBhbm5vdGF0ZWRQcmVkaWN0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0pKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgW11dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBGYWNlTWVzaDtcbn0oKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/keypoints.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/keypoints.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MESH_ANNOTATIONS = {\n    silhouette: [\n        10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288,\n        397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136,\n        172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109\n    ],\n    lipsUpperOuter: [61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291],\n    lipsLowerOuter: [146, 91, 181, 84, 17, 314, 405, 321, 375, 291],\n    lipsUpperInner: [78, 191, 80, 81, 82, 13, 312, 311, 310, 415, 308],\n    lipsLowerInner: [78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308],\n    rightEyeUpper0: [246, 161, 160, 159, 158, 157, 173],\n    rightEyeLower0: [33, 7, 163, 144, 145, 153, 154, 155, 133],\n    rightEyeUpper1: [247, 30, 29, 27, 28, 56, 190],\n    rightEyeLower1: [130, 25, 110, 24, 23, 22, 26, 112, 243],\n    rightEyeUpper2: [113, 225, 224, 223, 222, 221, 189],\n    rightEyeLower2: [226, 31, 228, 229, 230, 231, 232, 233, 244],\n    rightEyeLower3: [143, 111, 117, 118, 119, 120, 121, 128, 245],\n    rightEyebrowUpper: [156, 70, 63, 105, 66, 107, 55, 193],\n    rightEyebrowLower: [35, 124, 46, 53, 52, 65],\n    rightEyeIris: [473, 474, 475, 476, 477],\n    leftEyeUpper0: [466, 388, 387, 386, 385, 384, 398],\n    leftEyeLower0: [263, 249, 390, 373, 374, 380, 381, 382, 362],\n    leftEyeUpper1: [467, 260, 259, 257, 258, 286, 414],\n    leftEyeLower1: [359, 255, 339, 254, 253, 252, 256, 341, 463],\n    leftEyeUpper2: [342, 445, 444, 443, 442, 441, 413],\n    leftEyeLower2: [446, 261, 448, 449, 450, 451, 452, 453, 464],\n    leftEyeLower3: [372, 340, 346, 347, 348, 349, 350, 357, 465],\n    leftEyebrowUpper: [383, 300, 293, 334, 296, 336, 285, 417],\n    leftEyebrowLower: [265, 353, 276, 283, 282, 295],\n    leftEyeIris: [468, 469, 470, 471, 472],\n    midwayBetweenEyes: [168],\n    noseTip: [1],\n    noseBottom: [2],\n    noseRightCorner: [98],\n    noseLeftCorner: [327],\n    rightCheek: [205],\n    leftCheek: [425]\n};\n//# sourceMappingURL=keypoints.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3ctbW9kZWxzL2ZhY2UtbGFuZG1hcmtzLWRldGVjdGlvbi9kaXN0L21lZGlhcGlwZS1mYWNlbWVzaC9rZXlwb2ludHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWVjb21tZXJjZS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93LW1vZGVscy9mYWNlLWxhbmRtYXJrcy1kZXRlY3Rpb24vZGlzdC9tZWRpYXBpcGUtZmFjZW1lc2gva2V5cG9pbnRzLmpzP2IyNmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NRVNIX0FOTk9UQVRJT05TID0ge1xuICAgIHNpbGhvdWV0dGU6IFtcbiAgICAgICAgMTAsIDMzOCwgMjk3LCAzMzIsIDI4NCwgMjUxLCAzODksIDM1NiwgNDU0LCAzMjMsIDM2MSwgMjg4LFxuICAgICAgICAzOTcsIDM2NSwgMzc5LCAzNzgsIDQwMCwgMzc3LCAxNTIsIDE0OCwgMTc2LCAxNDksIDE1MCwgMTM2LFxuICAgICAgICAxNzIsIDU4LCAxMzIsIDkzLCAyMzQsIDEyNywgMTYyLCAyMSwgNTQsIDEwMywgNjcsIDEwOVxuICAgIF0sXG4gICAgbGlwc1VwcGVyT3V0ZXI6IFs2MSwgMTg1LCA0MCwgMzksIDM3LCAwLCAyNjcsIDI2OSwgMjcwLCA0MDksIDI5MV0sXG4gICAgbGlwc0xvd2VyT3V0ZXI6IFsxNDYsIDkxLCAxODEsIDg0LCAxNywgMzE0LCA0MDUsIDMyMSwgMzc1LCAyOTFdLFxuICAgIGxpcHNVcHBlcklubmVyOiBbNzgsIDE5MSwgODAsIDgxLCA4MiwgMTMsIDMxMiwgMzExLCAzMTAsIDQxNSwgMzA4XSxcbiAgICBsaXBzTG93ZXJJbm5lcjogWzc4LCA5NSwgODgsIDE3OCwgODcsIDE0LCAzMTcsIDQwMiwgMzE4LCAzMjQsIDMwOF0sXG4gICAgcmlnaHRFeWVVcHBlcjA6IFsyNDYsIDE2MSwgMTYwLCAxNTksIDE1OCwgMTU3LCAxNzNdLFxuICAgIHJpZ2h0RXllTG93ZXIwOiBbMzMsIDcsIDE2MywgMTQ0LCAxNDUsIDE1MywgMTU0LCAxNTUsIDEzM10sXG4gICAgcmlnaHRFeWVVcHBlcjE6IFsyNDcsIDMwLCAyOSwgMjcsIDI4LCA1NiwgMTkwXSxcbiAgICByaWdodEV5ZUxvd2VyMTogWzEzMCwgMjUsIDExMCwgMjQsIDIzLCAyMiwgMjYsIDExMiwgMjQzXSxcbiAgICByaWdodEV5ZVVwcGVyMjogWzExMywgMjI1LCAyMjQsIDIyMywgMjIyLCAyMjEsIDE4OV0sXG4gICAgcmlnaHRFeWVMb3dlcjI6IFsyMjYsIDMxLCAyMjgsIDIyOSwgMjMwLCAyMzEsIDIzMiwgMjMzLCAyNDRdLFxuICAgIHJpZ2h0RXllTG93ZXIzOiBbMTQzLCAxMTEsIDExNywgMTE4LCAxMTksIDEyMCwgMTIxLCAxMjgsIDI0NV0sXG4gICAgcmlnaHRFeWVicm93VXBwZXI6IFsxNTYsIDcwLCA2MywgMTA1LCA2NiwgMTA3LCA1NSwgMTkzXSxcbiAgICByaWdodEV5ZWJyb3dMb3dlcjogWzM1LCAxMjQsIDQ2LCA1MywgNTIsIDY1XSxcbiAgICByaWdodEV5ZUlyaXM6IFs0NzMsIDQ3NCwgNDc1LCA0NzYsIDQ3N10sXG4gICAgbGVmdEV5ZVVwcGVyMDogWzQ2NiwgMzg4LCAzODcsIDM4NiwgMzg1LCAzODQsIDM5OF0sXG4gICAgbGVmdEV5ZUxvd2VyMDogWzI2MywgMjQ5LCAzOTAsIDM3MywgMzc0LCAzODAsIDM4MSwgMzgyLCAzNjJdLFxuICAgIGxlZnRFeWVVcHBlcjE6IFs0NjcsIDI2MCwgMjU5LCAyNTcsIDI1OCwgMjg2LCA0MTRdLFxuICAgIGxlZnRFeWVMb3dlcjE6IFszNTksIDI1NSwgMzM5LCAyNTQsIDI1MywgMjUyLCAyNTYsIDM0MSwgNDYzXSxcbiAgICBsZWZ0RXllVXBwZXIyOiBbMzQyLCA0NDUsIDQ0NCwgNDQzLCA0NDIsIDQ0MSwgNDEzXSxcbiAgICBsZWZ0RXllTG93ZXIyOiBbNDQ2LCAyNjEsIDQ0OCwgNDQ5LCA0NTAsIDQ1MSwgNDUyLCA0NTMsIDQ2NF0sXG4gICAgbGVmdEV5ZUxvd2VyMzogWzM3MiwgMzQwLCAzNDYsIDM0NywgMzQ4LCAzNDksIDM1MCwgMzU3LCA0NjVdLFxuICAgIGxlZnRFeWVicm93VXBwZXI6IFszODMsIDMwMCwgMjkzLCAzMzQsIDI5NiwgMzM2LCAyODUsIDQxN10sXG4gICAgbGVmdEV5ZWJyb3dMb3dlcjogWzI2NSwgMzUzLCAyNzYsIDI4MywgMjgyLCAyOTVdLFxuICAgIGxlZnRFeWVJcmlzOiBbNDY4LCA0NjksIDQ3MCwgNDcxLCA0NzJdLFxuICAgIG1pZHdheUJldHdlZW5FeWVzOiBbMTY4XSxcbiAgICBub3NlVGlwOiBbMV0sXG4gICAgbm9zZUJvdHRvbTogWzJdLFxuICAgIG5vc2VSaWdodENvcm5lcjogWzk4XSxcbiAgICBub3NlTGVmdENvcm5lcjogWzMyN10sXG4gICAgcmlnaHRDaGVlazogWzIwNV0sXG4gICAgbGVmdENoZWVrOiBbNDI1XVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXBvaW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/keypoints.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/pipeline.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/pipeline.js ***!
  \******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar tf = __webpack_require__(/*! @tensorflow/tfjs-core */ \"(ssr)/./node_modules/@tensorflow/tfjs-core/dist/tf-core.node.js\");\nvar box_1 = __webpack_require__(/*! ./box */ \"(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/box.js\");\nvar keypoints_1 = __webpack_require__(/*! ./keypoints */ \"(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/keypoints.js\");\nvar util_1 = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/util.js\");\nvar LANDMARKS_COUNT = 468;\nvar UPDATE_REGION_OF_INTEREST_IOU_THRESHOLD = 0.25;\nvar MESH_MOUTH_INDEX = 13;\nvar MESH_KEYPOINTS_LINE_OF_SYMMETRY_INDICES = [MESH_MOUTH_INDEX, keypoints_1.MESH_ANNOTATIONS['midwayBetweenEyes'][0]];\nvar BLAZEFACE_MOUTH_INDEX = 3;\nvar BLAZEFACE_NOSE_INDEX = 2;\nvar BLAZEFACE_KEYPOINTS_LINE_OF_SYMMETRY_INDICES = [BLAZEFACE_MOUTH_INDEX, BLAZEFACE_NOSE_INDEX];\nvar LEFT_EYE_OUTLINE = keypoints_1.MESH_ANNOTATIONS['leftEyeLower0'];\nvar LEFT_EYE_BOUNDS = [LEFT_EYE_OUTLINE[0], LEFT_EYE_OUTLINE[LEFT_EYE_OUTLINE.length - 1]];\nvar RIGHT_EYE_OUTLINE = keypoints_1.MESH_ANNOTATIONS['rightEyeLower0'];\nvar RIGHT_EYE_BOUNDS = [RIGHT_EYE_OUTLINE[0], RIGHT_EYE_OUTLINE[RIGHT_EYE_OUTLINE.length - 1]];\nvar IRIS_UPPER_CENTER_INDEX = 3;\nvar IRIS_LOWER_CENTER_INDEX = 4;\nvar IRIS_IRIS_INDEX = 71;\nvar IRIS_NUM_COORDINATES = 76;\n// Factor by which to enlarge the box around the eye landmarks so the input\n// region matches the expectations of the iris model.\nvar ENLARGE_EYE_RATIO = 2.3;\nvar IRIS_MODEL_INPUT_SIZE = 64;\n// A mapping from facemesh model keypoints to iris model keypoints.\nvar MESH_TO_IRIS_INDICES_MAP = [\n    { key: 'EyeUpper0', indices: [9, 10, 11, 12, 13, 14, 15] },\n    { key: 'EyeUpper1', indices: [25, 26, 27, 28, 29, 30, 31] },\n    { key: 'EyeUpper2', indices: [41, 42, 43, 44, 45, 46, 47] },\n    { key: 'EyeLower0', indices: [0, 1, 2, 3, 4, 5, 6, 7, 8] },\n    { key: 'EyeLower1', indices: [16, 17, 18, 19, 20, 21, 22, 23, 24] },\n    { key: 'EyeLower2', indices: [32, 33, 34, 35, 36, 37, 38, 39, 40] },\n    { key: 'EyeLower3', indices: [54, 55, 56, 57, 58, 59, 60, 61, 62] },\n    { key: 'EyebrowUpper', indices: [63, 64, 65, 66, 67, 68, 69, 70] },\n    { key: 'EyebrowLower', indices: [48, 49, 50, 51, 52, 53] }\n];\n// Replace the raw coordinates returned by facemesh with refined iris model\n// coordinates.\n// Update the z coordinate to be an average of the original and the new. This\n// produces the best visual effect.\nfunction replaceRawCoordinates(rawCoords, newCoords, prefix, keys) {\n    for (var i = 0; i < MESH_TO_IRIS_INDICES_MAP.length; i++) {\n        var _a = MESH_TO_IRIS_INDICES_MAP[i], key = _a.key, indices = _a.indices;\n        var originalIndices = keypoints_1.MESH_ANNOTATIONS[\"\" + prefix + key];\n        var shouldReplaceAllKeys = keys == null;\n        if (shouldReplaceAllKeys || keys.includes(key)) {\n            for (var j = 0; j < indices.length; j++) {\n                var index = indices[j];\n                rawCoords[originalIndices[j]] = [\n                    newCoords[index][0], newCoords[index][1],\n                    (newCoords[index][2] + rawCoords[originalIndices[j]][2]) / 2\n                ];\n            }\n        }\n    }\n}\n// The Pipeline coordinates between the bounding box and skeleton models.\nvar Pipeline = /** @class */ (function () {\n    function Pipeline(boundingBoxDetector, meshDetector, meshWidth, meshHeight, maxContinuousChecks, maxFaces, irisModel) {\n        // An array of facial bounding boxes.\n        this.regionsOfInterest = [];\n        this.runsWithoutFaceDetector = 0;\n        this.boundingBoxDetector = boundingBoxDetector;\n        this.meshDetector = meshDetector;\n        this.irisModel = irisModel;\n        this.meshWidth = meshWidth;\n        this.meshHeight = meshHeight;\n        this.maxContinuousChecks = maxContinuousChecks;\n        this.maxFaces = maxFaces;\n    }\n    Pipeline.prototype.transformRawCoords = function (rawCoords, box, angle, rotationMatrix) {\n        var _this = this;\n        var boxSize = box_1.getBoxSize({ startPoint: box.startPoint, endPoint: box.endPoint });\n        var scaleFactor = [boxSize[0] / this.meshWidth, boxSize[1] / this.meshHeight];\n        var coordsScaled = rawCoords.map(function (coord) { return ([\n            scaleFactor[0] * (coord[0] - _this.meshWidth / 2),\n            scaleFactor[1] * (coord[1] - _this.meshHeight / 2), coord[2]\n        ]); });\n        var coordsRotationMatrix = util_1.buildRotationMatrix(angle, [0, 0]);\n        var coordsRotated = coordsScaled.map(function (coord) {\n            return (util_1.rotatePoint(coord, coordsRotationMatrix).concat([coord[2]]));\n        });\n        var inverseRotationMatrix = util_1.invertTransformMatrix(rotationMatrix);\n        var boxCenter = box_1.getBoxCenter({ startPoint: box.startPoint, endPoint: box.endPoint }).concat([\n            1\n        ]);\n        var originalBoxCenter = [\n            util_1.dot(boxCenter, inverseRotationMatrix[0]),\n            util_1.dot(boxCenter, inverseRotationMatrix[1])\n        ];\n        return coordsRotated.map(function (coord) { return ([\n            coord[0] + originalBoxCenter[0],\n            coord[1] + originalBoxCenter[1], coord[2]\n        ]); });\n    };\n    Pipeline.prototype.getLeftToRightEyeDepthDifference = function (rawCoords) {\n        var leftEyeZ = rawCoords[LEFT_EYE_BOUNDS[0]][2];\n        var rightEyeZ = rawCoords[RIGHT_EYE_BOUNDS[0]][2];\n        return leftEyeZ - rightEyeZ;\n    };\n    // Returns a box describing a cropped region around the eye fit for passing to\n    // the iris model.\n    Pipeline.prototype.getEyeBox = function (rawCoords, face, eyeInnerCornerIndex, eyeOuterCornerIndex, flip) {\n        if (flip === void 0) { flip = false; }\n        var box = box_1.squarifyBox(box_1.enlargeBox(this.calculateLandmarksBoundingBox([rawCoords[eyeInnerCornerIndex], rawCoords[eyeOuterCornerIndex]]), ENLARGE_EYE_RATIO));\n        var boxSize = box_1.getBoxSize(box);\n        var crop = tf.image.cropAndResize(face, [[\n                box.startPoint[1] / this.meshHeight,\n                box.startPoint[0] / this.meshWidth, box.endPoint[1] / this.meshHeight,\n                box.endPoint[0] / this.meshWidth\n            ]], [0], [IRIS_MODEL_INPUT_SIZE, IRIS_MODEL_INPUT_SIZE]);\n        if (flip) {\n            crop = tf.image.flipLeftRight(crop);\n        }\n        return { box: box, boxSize: boxSize, crop: crop };\n    };\n    // Given a cropped image of an eye, returns the coordinates of the contours\n    // surrounding the eye and the iris.\n    Pipeline.prototype.getEyeCoords = function (eyeData, eyeBox, eyeBoxSize, flip) {\n        if (flip === void 0) { flip = false; }\n        var eyeRawCoords = [];\n        for (var i = 0; i < IRIS_NUM_COORDINATES; i++) {\n            var x = eyeData[i * 3];\n            var y = eyeData[i * 3 + 1];\n            var z = eyeData[i * 3 + 2];\n            eyeRawCoords.push([\n                (flip ? (1 - (x / IRIS_MODEL_INPUT_SIZE)) :\n                    (x / IRIS_MODEL_INPUT_SIZE)) *\n                    eyeBoxSize[0] +\n                    eyeBox.startPoint[0],\n                (y / IRIS_MODEL_INPUT_SIZE) * eyeBoxSize[1] + eyeBox.startPoint[1], z\n            ]);\n        }\n        return { rawCoords: eyeRawCoords, iris: eyeRawCoords.slice(IRIS_IRIS_INDEX) };\n    };\n    // The z-coordinates returned for the iris are unreliable, so we take the z\n    // values from the surrounding keypoints.\n    Pipeline.prototype.getAdjustedIrisCoords = function (rawCoords, irisCoords, direction) {\n        var upperCenterZ = rawCoords[keypoints_1.MESH_ANNOTATIONS[direction + \"EyeUpper0\"][IRIS_UPPER_CENTER_INDEX]][2];\n        var lowerCenterZ = rawCoords[keypoints_1.MESH_ANNOTATIONS[direction + \"EyeLower0\"][IRIS_LOWER_CENTER_INDEX]][2];\n        var averageZ = (upperCenterZ + lowerCenterZ) / 2;\n        // Iris indices:\n        // 0: center | 1: right | 2: above | 3: left | 4: below\n        return irisCoords.map(function (coord, i) {\n            var z = averageZ;\n            if (i === 2) {\n                z = upperCenterZ;\n            }\n            else if (i === 4) {\n                z = lowerCenterZ;\n            }\n            return [coord[0], coord[1], z];\n        });\n    };\n    /**\n     * Returns an array of predictions for each face in the input.\n     * @param input - tensor of shape [1, H, W, 3].\n     * @param predictIrises - Whether to return keypoints for the irises.\n     */\n    Pipeline.prototype.predict = function (input, predictIrises) {\n        return __awaiter(this, void 0, void 0, function () {\n            var returnTensors, annotateFace, _a, boxes, scaleFactor_1, scaledBoxes;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!this.shouldUpdateRegionsOfInterest()) return [3 /*break*/, 2];\n                        returnTensors = false;\n                        annotateFace = true;\n                        return [4 /*yield*/, this.boundingBoxDetector.getBoundingBoxes(input, returnTensors, annotateFace)];\n                    case 1:\n                        _a = _b.sent(), boxes = _a.boxes, scaleFactor_1 = _a.scaleFactor;\n                        if (boxes.length === 0) {\n                            this.regionsOfInterest = [];\n                            return [2 /*return*/, null];\n                        }\n                        scaledBoxes = boxes.map(function (prediction) {\n                            var predictionBoxCPU = {\n                                startPoint: tf.squeeze(prediction.box.startPoint).arraySync(),\n                                endPoint: tf.squeeze(prediction.box.endPoint).arraySync()\n                            };\n                            var scaledBox = box_1.scaleBoxCoordinates(predictionBoxCPU, scaleFactor_1);\n                            var enlargedBox = box_1.enlargeBox(scaledBox);\n                            var squarifiedBox = box_1.squarifyBox(enlargedBox);\n                            return __assign({}, squarifiedBox, { landmarks: prediction.landmarks.arraySync() });\n                        });\n                        boxes.forEach(function (box) {\n                            if (box != null && box.startPoint != null) {\n                                box.startEndTensor.dispose();\n                                box.startPoint.dispose();\n                                box.endPoint.dispose();\n                            }\n                        });\n                        this.updateRegionsOfInterest(scaledBoxes);\n                        this.runsWithoutFaceDetector = 0;\n                        return [3 /*break*/, 3];\n                    case 2:\n                        this.runsWithoutFaceDetector++;\n                        _b.label = 3;\n                    case 3: return [2 /*return*/, tf.tidy(function () {\n                            return _this.regionsOfInterest.map(function (box, i) {\n                                var angle = 0;\n                                // The facial bounding box landmarks could come either from blazeface\n                                // (if we are using a fresh box), or from the mesh model (if we are\n                                // reusing an old box).\n                                var boxLandmarksFromMeshModel = box.landmarks.length >= LANDMARKS_COUNT;\n                                var indexOfMouth = MESH_KEYPOINTS_LINE_OF_SYMMETRY_INDICES[0], indexOfForehead = MESH_KEYPOINTS_LINE_OF_SYMMETRY_INDICES[1];\n                                if (boxLandmarksFromMeshModel === false) {\n                                    indexOfMouth = BLAZEFACE_KEYPOINTS_LINE_OF_SYMMETRY_INDICES[0], indexOfForehead = BLAZEFACE_KEYPOINTS_LINE_OF_SYMMETRY_INDICES[1];\n                                }\n                                angle = util_1.computeRotation(box.landmarks[indexOfMouth], box.landmarks[indexOfForehead]);\n                                var faceCenter = box_1.getBoxCenter({ startPoint: box.startPoint, endPoint: box.endPoint });\n                                var faceCenterNormalized = [faceCenter[0] / input.shape[2], faceCenter[1] / input.shape[1]];\n                                var rotatedImage = input;\n                                var rotationMatrix = util_1.IDENTITY_MATRIX;\n                                if (angle !== 0) {\n                                    rotatedImage =\n                                        tf.image.rotateWithOffset(input, angle, 0, faceCenterNormalized);\n                                    rotationMatrix = util_1.buildRotationMatrix(-angle, faceCenter);\n                                }\n                                var boxCPU = { startPoint: box.startPoint, endPoint: box.endPoint };\n                                var face = tf.div(box_1.cutBoxFromImageAndResize(boxCPU, rotatedImage, [\n                                    _this.meshHeight, _this.meshWidth\n                                ]), 255);\n                                // The first returned tensor represents facial contours, which are\n                                // included in the coordinates.\n                                var _a = _this.meshDetector.predict(face), flag = _a[1], coords = _a[2];\n                                var coordsReshaped = tf.reshape(coords, [-1, 3]);\n                                var rawCoords = coordsReshaped.arraySync();\n                                if (predictIrises) {\n                                    var _b = _this.getEyeBox(rawCoords, face, LEFT_EYE_BOUNDS[0], LEFT_EYE_BOUNDS[1], true), leftEyeBox = _b.box, leftEyeBoxSize = _b.boxSize, leftEyeCrop = _b.crop;\n                                    var _c = _this.getEyeBox(rawCoords, face, RIGHT_EYE_BOUNDS[0], RIGHT_EYE_BOUNDS[1]), rightEyeBox = _c.box, rightEyeBoxSize = _c.boxSize, rightEyeCrop = _c.crop;\n                                    var eyePredictions = (_this.irisModel.predict(tf.concat([leftEyeCrop, rightEyeCrop])));\n                                    var eyePredictionsData = eyePredictions.dataSync();\n                                    var leftEyeData = eyePredictionsData.slice(0, IRIS_NUM_COORDINATES * 3);\n                                    var _d = _this.getEyeCoords(leftEyeData, leftEyeBox, leftEyeBoxSize, true), leftEyeRawCoords = _d.rawCoords, leftIrisRawCoords = _d.iris;\n                                    var rightEyeData = eyePredictionsData.slice(IRIS_NUM_COORDINATES * 3);\n                                    var _e = _this.getEyeCoords(rightEyeData, rightEyeBox, rightEyeBoxSize), rightEyeRawCoords = _e.rawCoords, rightIrisRawCoords = _e.iris;\n                                    var leftToRightEyeDepthDifference = _this.getLeftToRightEyeDepthDifference(rawCoords);\n                                    if (Math.abs(leftToRightEyeDepthDifference) <\n                                        30) { // User is looking straight ahead.\n                                        replaceRawCoordinates(rawCoords, leftEyeRawCoords, 'left');\n                                        replaceRawCoordinates(rawCoords, rightEyeRawCoords, 'right');\n                                    }\n                                    else if (leftToRightEyeDepthDifference < 1) { // User is looking\n                                        // towards the\n                                        // right.\n                                        // If the user is looking to the left or to the right, the iris\n                                        // coordinates tend to diverge too much from the mesh coordinates\n                                        // for them to be merged. So we only update a single contour line\n                                        // above and below the eye.\n                                        replaceRawCoordinates(rawCoords, leftEyeRawCoords, 'left', ['EyeUpper0', 'EyeLower0']);\n                                    }\n                                    else { // User is looking towards the left.\n                                        replaceRawCoordinates(rawCoords, rightEyeRawCoords, 'right', ['EyeUpper0', 'EyeLower0']);\n                                    }\n                                    var adjustedLeftIrisCoords = _this.getAdjustedIrisCoords(rawCoords, leftIrisRawCoords, 'left');\n                                    var adjustedRightIrisCoords = _this.getAdjustedIrisCoords(rawCoords, rightIrisRawCoords, 'right');\n                                    rawCoords = rawCoords.concat(adjustedLeftIrisCoords)\n                                        .concat(adjustedRightIrisCoords);\n                                }\n                                var transformedCoordsData = _this.transformRawCoords(rawCoords, box, angle, rotationMatrix);\n                                var transformedCoords = tf.tensor2d(transformedCoordsData);\n                                var landmarksBox = box_1.enlargeBox(_this.calculateLandmarksBoundingBox(transformedCoordsData));\n                                var squarifiedLandmarksBox = box_1.squarifyBox(landmarksBox);\n                                _this.regionsOfInterest[i] = __assign({}, squarifiedLandmarksBox, { landmarks: transformedCoords.arraySync() });\n                                var prediction = {\n                                    coords: tf.tensor2d(rawCoords, [rawCoords.length, 3]),\n                                    scaledCoords: transformedCoords,\n                                    box: landmarksBox,\n                                    flag: tf.squeeze(flag)\n                                };\n                                return prediction;\n                            });\n                        })];\n                }\n            });\n        });\n    };\n    // Updates regions of interest if the intersection over union between\n    // the incoming and previous regions falls below a threshold.\n    Pipeline.prototype.updateRegionsOfInterest = function (boxes) {\n        for (var i = 0; i < boxes.length; i++) {\n            var box = boxes[i];\n            var previousBox = this.regionsOfInterest[i];\n            var iou = 0;\n            if (previousBox && previousBox.startPoint) {\n                var _a = box.startPoint, boxStartX = _a[0], boxStartY = _a[1];\n                var _b = box.endPoint, boxEndX = _b[0], boxEndY = _b[1];\n                var _c = previousBox.startPoint, previousBoxStartX = _c[0], previousBoxStartY = _c[1];\n                var _d = previousBox.endPoint, previousBoxEndX = _d[0], previousBoxEndY = _d[1];\n                var xStartMax = Math.max(boxStartX, previousBoxStartX);\n                var yStartMax = Math.max(boxStartY, previousBoxStartY);\n                var xEndMin = Math.min(boxEndX, previousBoxEndX);\n                var yEndMin = Math.min(boxEndY, previousBoxEndY);\n                var intersection = (xEndMin - xStartMax) * (yEndMin - yStartMax);\n                var boxArea = (boxEndX - boxStartX) * (boxEndY - boxStartY);\n                var previousBoxArea = (previousBoxEndX - previousBoxStartX) *\n                    (previousBoxEndY - boxStartY);\n                iou = intersection / (boxArea + previousBoxArea - intersection);\n            }\n            if (iou < UPDATE_REGION_OF_INTEREST_IOU_THRESHOLD) {\n                this.regionsOfInterest[i] = box;\n            }\n        }\n        this.regionsOfInterest = this.regionsOfInterest.slice(0, boxes.length);\n    };\n    Pipeline.prototype.clearRegionOfInterest = function (index) {\n        if (this.regionsOfInterest[index] != null) {\n            this.regionsOfInterest = this.regionsOfInterest.slice(0, index).concat(this.regionsOfInterest.slice(index + 1));\n        }\n    };\n    Pipeline.prototype.shouldUpdateRegionsOfInterest = function () {\n        var roisCount = this.regionsOfInterest.length;\n        var noROIs = roisCount === 0;\n        if (this.maxFaces === 1 || noROIs) {\n            return noROIs;\n        }\n        return roisCount !== this.maxFaces &&\n            this.runsWithoutFaceDetector >= this.maxContinuousChecks;\n    };\n    Pipeline.prototype.calculateLandmarksBoundingBox = function (landmarks) {\n        var xs = landmarks.map(function (d) { return d[0]; });\n        var ys = landmarks.map(function (d) { return d[1]; });\n        var startPoint = [Math.min.apply(Math, xs), Math.min.apply(Math, ys)];\n        var endPoint = [Math.max.apply(Math, xs), Math.max.apply(Math, ys)];\n        return { startPoint: startPoint, endPoint: endPoint };\n    };\n    return Pipeline;\n}());\nexports.Pipeline = Pipeline;\n//# sourceMappingURL=pipeline.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3ctbW9kZWxzL2ZhY2UtbGFuZG1hcmtzLWRldGVjdGlvbi9kaXN0L21lZGlhcGlwZS1mYWNlbWVzaC9waXBlbGluZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDLGlFQUFpRSx3QkFBd0I7QUFDekg7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsU0FBUyxtQkFBTyxDQUFDLDhGQUF1QjtBQUN4QyxZQUFZLG1CQUFPLENBQUMsOEdBQU87QUFDM0Isa0JBQWtCLG1CQUFPLENBQUMsMEhBQWE7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLGdIQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0RBQXdEO0FBQzlELE1BQU0seURBQXlEO0FBQy9ELE1BQU0seURBQXlEO0FBQy9ELE1BQU0sd0RBQXdEO0FBQzlELE1BQU0saUVBQWlFO0FBQ3ZFLE1BQU0saUVBQWlFO0FBQ3ZFLE1BQU0saUVBQWlFO0FBQ3ZFLE1BQU0sZ0VBQWdFO0FBQ3RFLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUNBQXFDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvREFBb0Q7QUFDN0Y7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw2Q0FBNkMsb0RBQW9EO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsbUJBQW1CLDZDQUE2QztBQUM5Ryx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxvREFBb0Q7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLDRCQUE0QiwwQ0FBMEM7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsQ0FBQztBQUNELGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWVjb21tZXJjZS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93LW1vZGVscy9mYWNlLWxhbmRtYXJrcy1kZXRlY3Rpb24vZGlzdC9tZWRpYXBpcGUtZmFjZW1lc2gvcGlwZWxpbmUuanM/YWE4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZiA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgYm94XzEgPSByZXF1aXJlKFwiLi9ib3hcIik7XG52YXIga2V5cG9pbnRzXzEgPSByZXF1aXJlKFwiLi9rZXlwb2ludHNcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBMQU5ETUFSS1NfQ09VTlQgPSA0Njg7XG52YXIgVVBEQVRFX1JFR0lPTl9PRl9JTlRFUkVTVF9JT1VfVEhSRVNIT0xEID0gMC4yNTtcbnZhciBNRVNIX01PVVRIX0lOREVYID0gMTM7XG52YXIgTUVTSF9LRVlQT0lOVFNfTElORV9PRl9TWU1NRVRSWV9JTkRJQ0VTID0gW01FU0hfTU9VVEhfSU5ERVgsIGtleXBvaW50c18xLk1FU0hfQU5OT1RBVElPTlNbJ21pZHdheUJldHdlZW5FeWVzJ11bMF1dO1xudmFyIEJMQVpFRkFDRV9NT1VUSF9JTkRFWCA9IDM7XG52YXIgQkxBWkVGQUNFX05PU0VfSU5ERVggPSAyO1xudmFyIEJMQVpFRkFDRV9LRVlQT0lOVFNfTElORV9PRl9TWU1NRVRSWV9JTkRJQ0VTID0gW0JMQVpFRkFDRV9NT1VUSF9JTkRFWCwgQkxBWkVGQUNFX05PU0VfSU5ERVhdO1xudmFyIExFRlRfRVlFX09VVExJTkUgPSBrZXlwb2ludHNfMS5NRVNIX0FOTk9UQVRJT05TWydsZWZ0RXllTG93ZXIwJ107XG52YXIgTEVGVF9FWUVfQk9VTkRTID0gW0xFRlRfRVlFX09VVExJTkVbMF0sIExFRlRfRVlFX09VVExJTkVbTEVGVF9FWUVfT1VUTElORS5sZW5ndGggLSAxXV07XG52YXIgUklHSFRfRVlFX09VVExJTkUgPSBrZXlwb2ludHNfMS5NRVNIX0FOTk9UQVRJT05TWydyaWdodEV5ZUxvd2VyMCddO1xudmFyIFJJR0hUX0VZRV9CT1VORFMgPSBbUklHSFRfRVlFX09VVExJTkVbMF0sIFJJR0hUX0VZRV9PVVRMSU5FW1JJR0hUX0VZRV9PVVRMSU5FLmxlbmd0aCAtIDFdXTtcbnZhciBJUklTX1VQUEVSX0NFTlRFUl9JTkRFWCA9IDM7XG52YXIgSVJJU19MT1dFUl9DRU5URVJfSU5ERVggPSA0O1xudmFyIElSSVNfSVJJU19JTkRFWCA9IDcxO1xudmFyIElSSVNfTlVNX0NPT1JESU5BVEVTID0gNzY7XG4vLyBGYWN0b3IgYnkgd2hpY2ggdG8gZW5sYXJnZSB0aGUgYm94IGFyb3VuZCB0aGUgZXllIGxhbmRtYXJrcyBzbyB0aGUgaW5wdXRcbi8vIHJlZ2lvbiBtYXRjaGVzIHRoZSBleHBlY3RhdGlvbnMgb2YgdGhlIGlyaXMgbW9kZWwuXG52YXIgRU5MQVJHRV9FWUVfUkFUSU8gPSAyLjM7XG52YXIgSVJJU19NT0RFTF9JTlBVVF9TSVpFID0gNjQ7XG4vLyBBIG1hcHBpbmcgZnJvbSBmYWNlbWVzaCBtb2RlbCBrZXlwb2ludHMgdG8gaXJpcyBtb2RlbCBrZXlwb2ludHMuXG52YXIgTUVTSF9UT19JUklTX0lORElDRVNfTUFQID0gW1xuICAgIHsga2V5OiAnRXllVXBwZXIwJywgaW5kaWNlczogWzksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTVdIH0sXG4gICAgeyBrZXk6ICdFeWVVcHBlcjEnLCBpbmRpY2VzOiBbMjUsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzFdIH0sXG4gICAgeyBrZXk6ICdFeWVVcHBlcjInLCBpbmRpY2VzOiBbNDEsIDQyLCA0MywgNDQsIDQ1LCA0NiwgNDddIH0sXG4gICAgeyBrZXk6ICdFeWVMb3dlcjAnLCBpbmRpY2VzOiBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOF0gfSxcbiAgICB7IGtleTogJ0V5ZUxvd2VyMScsIGluZGljZXM6IFsxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0XSB9LFxuICAgIHsga2V5OiAnRXllTG93ZXIyJywgaW5kaWNlczogWzMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LCAzOSwgNDBdIH0sXG4gICAgeyBrZXk6ICdFeWVMb3dlcjMnLCBpbmRpY2VzOiBbNTQsIDU1LCA1NiwgNTcsIDU4LCA1OSwgNjAsIDYxLCA2Ml0gfSxcbiAgICB7IGtleTogJ0V5ZWJyb3dVcHBlcicsIGluZGljZXM6IFs2MywgNjQsIDY1LCA2NiwgNjcsIDY4LCA2OSwgNzBdIH0sXG4gICAgeyBrZXk6ICdFeWVicm93TG93ZXInLCBpbmRpY2VzOiBbNDgsIDQ5LCA1MCwgNTEsIDUyLCA1M10gfVxuXTtcbi8vIFJlcGxhY2UgdGhlIHJhdyBjb29yZGluYXRlcyByZXR1cm5lZCBieSBmYWNlbWVzaCB3aXRoIHJlZmluZWQgaXJpcyBtb2RlbFxuLy8gY29vcmRpbmF0ZXMuXG4vLyBVcGRhdGUgdGhlIHogY29vcmRpbmF0ZSB0byBiZSBhbiBhdmVyYWdlIG9mIHRoZSBvcmlnaW5hbCBhbmQgdGhlIG5ldy4gVGhpc1xuLy8gcHJvZHVjZXMgdGhlIGJlc3QgdmlzdWFsIGVmZmVjdC5cbmZ1bmN0aW9uIHJlcGxhY2VSYXdDb29yZGluYXRlcyhyYXdDb29yZHMsIG5ld0Nvb3JkcywgcHJlZml4LCBrZXlzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNRVNIX1RPX0lSSVNfSU5ESUNFU19NQVAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9hID0gTUVTSF9UT19JUklTX0lORElDRVNfTUFQW2ldLCBrZXkgPSBfYS5rZXksIGluZGljZXMgPSBfYS5pbmRpY2VzO1xuICAgICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0ga2V5cG9pbnRzXzEuTUVTSF9BTk5PVEFUSU9OU1tcIlwiICsgcHJlZml4ICsga2V5XTtcbiAgICAgICAgdmFyIHNob3VsZFJlcGxhY2VBbGxLZXlzID0ga2V5cyA9PSBudWxsO1xuICAgICAgICBpZiAoc2hvdWxkUmVwbGFjZUFsbEtleXMgfHwga2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGluZGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBpbmRpY2VzW2pdO1xuICAgICAgICAgICAgICAgIHJhd0Nvb3Jkc1tvcmlnaW5hbEluZGljZXNbal1dID0gW1xuICAgICAgICAgICAgICAgICAgICBuZXdDb29yZHNbaW5kZXhdWzBdLCBuZXdDb29yZHNbaW5kZXhdWzFdLFxuICAgICAgICAgICAgICAgICAgICAobmV3Q29vcmRzW2luZGV4XVsyXSArIHJhd0Nvb3Jkc1tvcmlnaW5hbEluZGljZXNbal1dWzJdKSAvIDJcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8gVGhlIFBpcGVsaW5lIGNvb3JkaW5hdGVzIGJldHdlZW4gdGhlIGJvdW5kaW5nIGJveCBhbmQgc2tlbGV0b24gbW9kZWxzLlxudmFyIFBpcGVsaW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBpcGVsaW5lKGJvdW5kaW5nQm94RGV0ZWN0b3IsIG1lc2hEZXRlY3RvciwgbWVzaFdpZHRoLCBtZXNoSGVpZ2h0LCBtYXhDb250aW51b3VzQ2hlY2tzLCBtYXhGYWNlcywgaXJpc01vZGVsKSB7XG4gICAgICAgIC8vIEFuIGFycmF5IG9mIGZhY2lhbCBib3VuZGluZyBib3hlcy5cbiAgICAgICAgdGhpcy5yZWdpb25zT2ZJbnRlcmVzdCA9IFtdO1xuICAgICAgICB0aGlzLnJ1bnNXaXRob3V0RmFjZURldGVjdG9yID0gMDtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveERldGVjdG9yID0gYm91bmRpbmdCb3hEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5tZXNoRGV0ZWN0b3IgPSBtZXNoRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMuaXJpc01vZGVsID0gaXJpc01vZGVsO1xuICAgICAgICB0aGlzLm1lc2hXaWR0aCA9IG1lc2hXaWR0aDtcbiAgICAgICAgdGhpcy5tZXNoSGVpZ2h0ID0gbWVzaEhlaWdodDtcbiAgICAgICAgdGhpcy5tYXhDb250aW51b3VzQ2hlY2tzID0gbWF4Q29udGludW91c0NoZWNrcztcbiAgICAgICAgdGhpcy5tYXhGYWNlcyA9IG1heEZhY2VzO1xuICAgIH1cbiAgICBQaXBlbGluZS5wcm90b3R5cGUudHJhbnNmb3JtUmF3Q29vcmRzID0gZnVuY3Rpb24gKHJhd0Nvb3JkcywgYm94LCBhbmdsZSwgcm90YXRpb25NYXRyaXgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGJveFNpemUgPSBib3hfMS5nZXRCb3hTaXplKHsgc3RhcnRQb2ludDogYm94LnN0YXJ0UG9pbnQsIGVuZFBvaW50OiBib3guZW5kUG9pbnQgfSk7XG4gICAgICAgIHZhciBzY2FsZUZhY3RvciA9IFtib3hTaXplWzBdIC8gdGhpcy5tZXNoV2lkdGgsIGJveFNpemVbMV0gLyB0aGlzLm1lc2hIZWlnaHRdO1xuICAgICAgICB2YXIgY29vcmRzU2NhbGVkID0gcmF3Q29vcmRzLm1hcChmdW5jdGlvbiAoY29vcmQpIHsgcmV0dXJuIChbXG4gICAgICAgICAgICBzY2FsZUZhY3RvclswXSAqIChjb29yZFswXSAtIF90aGlzLm1lc2hXaWR0aCAvIDIpLFxuICAgICAgICAgICAgc2NhbGVGYWN0b3JbMV0gKiAoY29vcmRbMV0gLSBfdGhpcy5tZXNoSGVpZ2h0IC8gMiksIGNvb3JkWzJdXG4gICAgICAgIF0pOyB9KTtcbiAgICAgICAgdmFyIGNvb3Jkc1JvdGF0aW9uTWF0cml4ID0gdXRpbF8xLmJ1aWxkUm90YXRpb25NYXRyaXgoYW5nbGUsIFswLCAwXSk7XG4gICAgICAgIHZhciBjb29yZHNSb3RhdGVkID0gY29vcmRzU2NhbGVkLm1hcChmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgICAgIHJldHVybiAodXRpbF8xLnJvdGF0ZVBvaW50KGNvb3JkLCBjb29yZHNSb3RhdGlvbk1hdHJpeCkuY29uY2F0KFtjb29yZFsyXV0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpbnZlcnNlUm90YXRpb25NYXRyaXggPSB1dGlsXzEuaW52ZXJ0VHJhbnNmb3JtTWF0cml4KHJvdGF0aW9uTWF0cml4KTtcbiAgICAgICAgdmFyIGJveENlbnRlciA9IGJveF8xLmdldEJveENlbnRlcih7IHN0YXJ0UG9pbnQ6IGJveC5zdGFydFBvaW50LCBlbmRQb2ludDogYm94LmVuZFBvaW50IH0pLmNvbmNhdChbXG4gICAgICAgICAgICAxXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgb3JpZ2luYWxCb3hDZW50ZXIgPSBbXG4gICAgICAgICAgICB1dGlsXzEuZG90KGJveENlbnRlciwgaW52ZXJzZVJvdGF0aW9uTWF0cml4WzBdKSxcbiAgICAgICAgICAgIHV0aWxfMS5kb3QoYm94Q2VudGVyLCBpbnZlcnNlUm90YXRpb25NYXRyaXhbMV0pXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBjb29yZHNSb3RhdGVkLm1hcChmdW5jdGlvbiAoY29vcmQpIHsgcmV0dXJuIChbXG4gICAgICAgICAgICBjb29yZFswXSArIG9yaWdpbmFsQm94Q2VudGVyWzBdLFxuICAgICAgICAgICAgY29vcmRbMV0gKyBvcmlnaW5hbEJveENlbnRlclsxXSwgY29vcmRbMl1cbiAgICAgICAgXSk7IH0pO1xuICAgIH07XG4gICAgUGlwZWxpbmUucHJvdG90eXBlLmdldExlZnRUb1JpZ2h0RXllRGVwdGhEaWZmZXJlbmNlID0gZnVuY3Rpb24gKHJhd0Nvb3Jkcykge1xuICAgICAgICB2YXIgbGVmdEV5ZVogPSByYXdDb29yZHNbTEVGVF9FWUVfQk9VTkRTWzBdXVsyXTtcbiAgICAgICAgdmFyIHJpZ2h0RXllWiA9IHJhd0Nvb3Jkc1tSSUdIVF9FWUVfQk9VTkRTWzBdXVsyXTtcbiAgICAgICAgcmV0dXJuIGxlZnRFeWVaIC0gcmlnaHRFeWVaO1xuICAgIH07XG4gICAgLy8gUmV0dXJucyBhIGJveCBkZXNjcmliaW5nIGEgY3JvcHBlZCByZWdpb24gYXJvdW5kIHRoZSBleWUgZml0IGZvciBwYXNzaW5nIHRvXG4gICAgLy8gdGhlIGlyaXMgbW9kZWwuXG4gICAgUGlwZWxpbmUucHJvdG90eXBlLmdldEV5ZUJveCA9IGZ1bmN0aW9uIChyYXdDb29yZHMsIGZhY2UsIGV5ZUlubmVyQ29ybmVySW5kZXgsIGV5ZU91dGVyQ29ybmVySW5kZXgsIGZsaXApIHtcbiAgICAgICAgaWYgKGZsaXAgPT09IHZvaWQgMCkgeyBmbGlwID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGJveCA9IGJveF8xLnNxdWFyaWZ5Qm94KGJveF8xLmVubGFyZ2VCb3godGhpcy5jYWxjdWxhdGVMYW5kbWFya3NCb3VuZGluZ0JveChbcmF3Q29vcmRzW2V5ZUlubmVyQ29ybmVySW5kZXhdLCByYXdDb29yZHNbZXllT3V0ZXJDb3JuZXJJbmRleF1dKSwgRU5MQVJHRV9FWUVfUkFUSU8pKTtcbiAgICAgICAgdmFyIGJveFNpemUgPSBib3hfMS5nZXRCb3hTaXplKGJveCk7XG4gICAgICAgIHZhciBjcm9wID0gdGYuaW1hZ2UuY3JvcEFuZFJlc2l6ZShmYWNlLCBbW1xuICAgICAgICAgICAgICAgIGJveC5zdGFydFBvaW50WzFdIC8gdGhpcy5tZXNoSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGJveC5zdGFydFBvaW50WzBdIC8gdGhpcy5tZXNoV2lkdGgsIGJveC5lbmRQb2ludFsxXSAvIHRoaXMubWVzaEhlaWdodCxcbiAgICAgICAgICAgICAgICBib3guZW5kUG9pbnRbMF0gLyB0aGlzLm1lc2hXaWR0aFxuICAgICAgICAgICAgXV0sIFswXSwgW0lSSVNfTU9ERUxfSU5QVVRfU0laRSwgSVJJU19NT0RFTF9JTlBVVF9TSVpFXSk7XG4gICAgICAgIGlmIChmbGlwKSB7XG4gICAgICAgICAgICBjcm9wID0gdGYuaW1hZ2UuZmxpcExlZnRSaWdodChjcm9wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBib3g6IGJveCwgYm94U2l6ZTogYm94U2l6ZSwgY3JvcDogY3JvcCB9O1xuICAgIH07XG4gICAgLy8gR2l2ZW4gYSBjcm9wcGVkIGltYWdlIG9mIGFuIGV5ZSwgcmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGNvbnRvdXJzXG4gICAgLy8gc3Vycm91bmRpbmcgdGhlIGV5ZSBhbmQgdGhlIGlyaXMuXG4gICAgUGlwZWxpbmUucHJvdG90eXBlLmdldEV5ZUNvb3JkcyA9IGZ1bmN0aW9uIChleWVEYXRhLCBleWVCb3gsIGV5ZUJveFNpemUsIGZsaXApIHtcbiAgICAgICAgaWYgKGZsaXAgPT09IHZvaWQgMCkgeyBmbGlwID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGV5ZVJhd0Nvb3JkcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IElSSVNfTlVNX0NPT1JESU5BVEVTOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB4ID0gZXllRGF0YVtpICogM107XG4gICAgICAgICAgICB2YXIgeSA9IGV5ZURhdGFbaSAqIDMgKyAxXTtcbiAgICAgICAgICAgIHZhciB6ID0gZXllRGF0YVtpICogMyArIDJdO1xuICAgICAgICAgICAgZXllUmF3Q29vcmRzLnB1c2goW1xuICAgICAgICAgICAgICAgIChmbGlwID8gKDEgLSAoeCAvIElSSVNfTU9ERUxfSU5QVVRfU0laRSkpIDpcbiAgICAgICAgICAgICAgICAgICAgKHggLyBJUklTX01PREVMX0lOUFVUX1NJWkUpKSAqXG4gICAgICAgICAgICAgICAgICAgIGV5ZUJveFNpemVbMF0gK1xuICAgICAgICAgICAgICAgICAgICBleWVCb3guc3RhcnRQb2ludFswXSxcbiAgICAgICAgICAgICAgICAoeSAvIElSSVNfTU9ERUxfSU5QVVRfU0laRSkgKiBleWVCb3hTaXplWzFdICsgZXllQm94LnN0YXJ0UG9pbnRbMV0sIHpcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhd0Nvb3JkczogZXllUmF3Q29vcmRzLCBpcmlzOiBleWVSYXdDb29yZHMuc2xpY2UoSVJJU19JUklTX0lOREVYKSB9O1xuICAgIH07XG4gICAgLy8gVGhlIHotY29vcmRpbmF0ZXMgcmV0dXJuZWQgZm9yIHRoZSBpcmlzIGFyZSB1bnJlbGlhYmxlLCBzbyB3ZSB0YWtlIHRoZSB6XG4gICAgLy8gdmFsdWVzIGZyb20gdGhlIHN1cnJvdW5kaW5nIGtleXBvaW50cy5cbiAgICBQaXBlbGluZS5wcm90b3R5cGUuZ2V0QWRqdXN0ZWRJcmlzQ29vcmRzID0gZnVuY3Rpb24gKHJhd0Nvb3JkcywgaXJpc0Nvb3JkcywgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciB1cHBlckNlbnRlclogPSByYXdDb29yZHNba2V5cG9pbnRzXzEuTUVTSF9BTk5PVEFUSU9OU1tkaXJlY3Rpb24gKyBcIkV5ZVVwcGVyMFwiXVtJUklTX1VQUEVSX0NFTlRFUl9JTkRFWF1dWzJdO1xuICAgICAgICB2YXIgbG93ZXJDZW50ZXJaID0gcmF3Q29vcmRzW2tleXBvaW50c18xLk1FU0hfQU5OT1RBVElPTlNbZGlyZWN0aW9uICsgXCJFeWVMb3dlcjBcIl1bSVJJU19MT1dFUl9DRU5URVJfSU5ERVhdXVsyXTtcbiAgICAgICAgdmFyIGF2ZXJhZ2VaID0gKHVwcGVyQ2VudGVyWiArIGxvd2VyQ2VudGVyWikgLyAyO1xuICAgICAgICAvLyBJcmlzIGluZGljZXM6XG4gICAgICAgIC8vIDA6IGNlbnRlciB8IDE6IHJpZ2h0IHwgMjogYWJvdmUgfCAzOiBsZWZ0IHwgNDogYmVsb3dcbiAgICAgICAgcmV0dXJuIGlyaXNDb29yZHMubWFwKGZ1bmN0aW9uIChjb29yZCwgaSkge1xuICAgICAgICAgICAgdmFyIHogPSBhdmVyYWdlWjtcbiAgICAgICAgICAgIGlmIChpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgeiA9IHVwcGVyQ2VudGVyWjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPT09IDQpIHtcbiAgICAgICAgICAgICAgICB6ID0gbG93ZXJDZW50ZXJaO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtjb29yZFswXSwgY29vcmRbMV0sIHpdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgcHJlZGljdGlvbnMgZm9yIGVhY2ggZmFjZSBpbiB0aGUgaW5wdXQuXG4gICAgICogQHBhcmFtIGlucHV0IC0gdGVuc29yIG9mIHNoYXBlIFsxLCBILCBXLCAzXS5cbiAgICAgKiBAcGFyYW0gcHJlZGljdElyaXNlcyAtIFdoZXRoZXIgdG8gcmV0dXJuIGtleXBvaW50cyBmb3IgdGhlIGlyaXNlcy5cbiAgICAgKi9cbiAgICBQaXBlbGluZS5wcm90b3R5cGUucHJlZGljdCA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZGljdElyaXNlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmV0dXJuVGVuc29ycywgYW5ub3RhdGVGYWNlLCBfYSwgYm94ZXMsIHNjYWxlRmFjdG9yXzEsIHNjYWxlZEJveGVzO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRVcGRhdGVSZWdpb25zT2ZJbnRlcmVzdCgpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblRlbnNvcnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRlRmFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmJvdW5kaW5nQm94RGV0ZWN0b3IuZ2V0Qm91bmRpbmdCb3hlcyhpbnB1dCwgcmV0dXJuVGVuc29ycywgYW5ub3RhdGVGYWNlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gX2Iuc2VudCgpLCBib3hlcyA9IF9hLmJveGVzLCBzY2FsZUZhY3Rvcl8xID0gX2Euc2NhbGVGYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm94ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWdpb25zT2ZJbnRlcmVzdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlZEJveGVzID0gYm94ZXMubWFwKGZ1bmN0aW9uIChwcmVkaWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZWRpY3Rpb25Cb3hDUFUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9pbnQ6IHRmLnNxdWVlemUocHJlZGljdGlvbi5ib3guc3RhcnRQb2ludCkuYXJyYXlTeW5jKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvaW50OiB0Zi5zcXVlZXplKHByZWRpY3Rpb24uYm94LmVuZFBvaW50KS5hcnJheVN5bmMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlZEJveCA9IGJveF8xLnNjYWxlQm94Q29vcmRpbmF0ZXMocHJlZGljdGlvbkJveENQVSwgc2NhbGVGYWN0b3JfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVubGFyZ2VkQm94ID0gYm94XzEuZW5sYXJnZUJveChzY2FsZWRCb3gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcXVhcmlmaWVkQm94ID0gYm94XzEuc3F1YXJpZnlCb3goZW5sYXJnZWRCb3gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbih7fSwgc3F1YXJpZmllZEJveCwgeyBsYW5kbWFya3M6IHByZWRpY3Rpb24ubGFuZG1hcmtzLmFycmF5U3luYygpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3hlcy5mb3JFYWNoKGZ1bmN0aW9uIChib3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm94ICE9IG51bGwgJiYgYm94LnN0YXJ0UG9pbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3guc3RhcnRFbmRUZW5zb3IuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3guc3RhcnRQb2ludC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveC5lbmRQb2ludC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlZ2lvbnNPZkludGVyZXN0KHNjYWxlZEJveGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnVuc1dpdGhvdXRGYWNlRGV0ZWN0b3IgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnVuc1dpdGhvdXRGYWNlRGV0ZWN0b3IrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgdGYudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlZ2lvbnNPZkludGVyZXN0Lm1hcChmdW5jdGlvbiAoYm94LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmYWNpYWwgYm91bmRpbmcgYm94IGxhbmRtYXJrcyBjb3VsZCBjb21lIGVpdGhlciBmcm9tIGJsYXplZmFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoaWYgd2UgYXJlIHVzaW5nIGEgZnJlc2ggYm94KSwgb3IgZnJvbSB0aGUgbWVzaCBtb2RlbCAoaWYgd2UgYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldXNpbmcgYW4gb2xkIGJveCkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3hMYW5kbWFya3NGcm9tTWVzaE1vZGVsID0gYm94LmxhbmRtYXJrcy5sZW5ndGggPj0gTEFORE1BUktTX0NPVU5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhPZk1vdXRoID0gTUVTSF9LRVlQT0lOVFNfTElORV9PRl9TWU1NRVRSWV9JTkRJQ0VTWzBdLCBpbmRleE9mRm9yZWhlYWQgPSBNRVNIX0tFWVBPSU5UU19MSU5FX09GX1NZTU1FVFJZX0lORElDRVNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib3hMYW5kbWFya3NGcm9tTWVzaE1vZGVsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhPZk1vdXRoID0gQkxBWkVGQUNFX0tFWVBPSU5UU19MSU5FX09GX1NZTU1FVFJZX0lORElDRVNbMF0sIGluZGV4T2ZGb3JlaGVhZCA9IEJMQVpFRkFDRV9LRVlQT0lOVFNfTElORV9PRl9TWU1NRVRSWV9JTkRJQ0VTWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gdXRpbF8xLmNvbXB1dGVSb3RhdGlvbihib3gubGFuZG1hcmtzW2luZGV4T2ZNb3V0aF0sIGJveC5sYW5kbWFya3NbaW5kZXhPZkZvcmVoZWFkXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWNlQ2VudGVyID0gYm94XzEuZ2V0Qm94Q2VudGVyKHsgc3RhcnRQb2ludDogYm94LnN0YXJ0UG9pbnQsIGVuZFBvaW50OiBib3guZW5kUG9pbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWNlQ2VudGVyTm9ybWFsaXplZCA9IFtmYWNlQ2VudGVyWzBdIC8gaW5wdXQuc2hhcGVbMl0sIGZhY2VDZW50ZXJbMV0gLyBpbnB1dC5zaGFwZVsxXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3RhdGVkSW1hZ2UgPSBpbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uTWF0cml4ID0gdXRpbF8xLklERU5USVRZX01BVFJJWDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ2xlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGVkSW1hZ2UgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmLmltYWdlLnJvdGF0ZVdpdGhPZmZzZXQoaW5wdXQsIGFuZ2xlLCAwLCBmYWNlQ2VudGVyTm9ybWFsaXplZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbk1hdHJpeCA9IHV0aWxfMS5idWlsZFJvdGF0aW9uTWF0cml4KC1hbmdsZSwgZmFjZUNlbnRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJveENQVSA9IHsgc3RhcnRQb2ludDogYm94LnN0YXJ0UG9pbnQsIGVuZFBvaW50OiBib3guZW5kUG9pbnQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhY2UgPSB0Zi5kaXYoYm94XzEuY3V0Qm94RnJvbUltYWdlQW5kUmVzaXplKGJveENQVSwgcm90YXRlZEltYWdlLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tZXNoSGVpZ2h0LCBfdGhpcy5tZXNoV2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIDI1NSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmaXJzdCByZXR1cm5lZCB0ZW5zb3IgcmVwcmVzZW50cyBmYWNpYWwgY29udG91cnMsIHdoaWNoIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmNsdWRlZCBpbiB0aGUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLm1lc2hEZXRlY3Rvci5wcmVkaWN0KGZhY2UpLCBmbGFnID0gX2FbMV0sIGNvb3JkcyA9IF9hWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRzUmVzaGFwZWQgPSB0Zi5yZXNoYXBlKGNvb3JkcywgWy0xLCAzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdDb29yZHMgPSBjb29yZHNSZXNoYXBlZC5hcnJheVN5bmMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWRpY3RJcmlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IF90aGlzLmdldEV5ZUJveChyYXdDb29yZHMsIGZhY2UsIExFRlRfRVlFX0JPVU5EU1swXSwgTEVGVF9FWUVfQk9VTkRTWzFdLCB0cnVlKSwgbGVmdEV5ZUJveCA9IF9iLmJveCwgbGVmdEV5ZUJveFNpemUgPSBfYi5ib3hTaXplLCBsZWZ0RXllQ3JvcCA9IF9iLmNyb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2MgPSBfdGhpcy5nZXRFeWVCb3gocmF3Q29vcmRzLCBmYWNlLCBSSUdIVF9FWUVfQk9VTkRTWzBdLCBSSUdIVF9FWUVfQk9VTkRTWzFdKSwgcmlnaHRFeWVCb3ggPSBfYy5ib3gsIHJpZ2h0RXllQm94U2l6ZSA9IF9jLmJveFNpemUsIHJpZ2h0RXllQ3JvcCA9IF9jLmNyb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXllUHJlZGljdGlvbnMgPSAoX3RoaXMuaXJpc01vZGVsLnByZWRpY3QodGYuY29uY2F0KFtsZWZ0RXllQ3JvcCwgcmlnaHRFeWVDcm9wXSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleWVQcmVkaWN0aW9uc0RhdGEgPSBleWVQcmVkaWN0aW9ucy5kYXRhU3luYygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnRFeWVEYXRhID0gZXllUHJlZGljdGlvbnNEYXRhLnNsaWNlKDAsIElSSVNfTlVNX0NPT1JESU5BVEVTICogMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2QgPSBfdGhpcy5nZXRFeWVDb29yZHMobGVmdEV5ZURhdGEsIGxlZnRFeWVCb3gsIGxlZnRFeWVCb3hTaXplLCB0cnVlKSwgbGVmdEV5ZVJhd0Nvb3JkcyA9IF9kLnJhd0Nvb3JkcywgbGVmdElyaXNSYXdDb29yZHMgPSBfZC5pcmlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0RXllRGF0YSA9IGV5ZVByZWRpY3Rpb25zRGF0YS5zbGljZShJUklTX05VTV9DT09SRElOQVRFUyAqIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9lID0gX3RoaXMuZ2V0RXllQ29vcmRzKHJpZ2h0RXllRGF0YSwgcmlnaHRFeWVCb3gsIHJpZ2h0RXllQm94U2l6ZSksIHJpZ2h0RXllUmF3Q29vcmRzID0gX2UucmF3Q29vcmRzLCByaWdodElyaXNSYXdDb29yZHMgPSBfZS5pcmlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnRUb1JpZ2h0RXllRGVwdGhEaWZmZXJlbmNlID0gX3RoaXMuZ2V0TGVmdFRvUmlnaHRFeWVEZXB0aERpZmZlcmVuY2UocmF3Q29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhsZWZ0VG9SaWdodEV5ZURlcHRoRGlmZmVyZW5jZSkgPFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMwKSB7IC8vIFVzZXIgaXMgbG9va2luZyBzdHJhaWdodCBhaGVhZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlUmF3Q29vcmRpbmF0ZXMocmF3Q29vcmRzLCBsZWZ0RXllUmF3Q29vcmRzLCAnbGVmdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VSYXdDb29yZGluYXRlcyhyYXdDb29yZHMsIHJpZ2h0RXllUmF3Q29vcmRzLCAncmlnaHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxlZnRUb1JpZ2h0RXllRGVwdGhEaWZmZXJlbmNlIDwgMSkgeyAvLyBVc2VyIGlzIGxvb2tpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0b3dhcmRzIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJpZ2h0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGlzIGxvb2tpbmcgdG8gdGhlIGxlZnQgb3IgdG8gdGhlIHJpZ2h0LCB0aGUgaXJpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvb3JkaW5hdGVzIHRlbmQgdG8gZGl2ZXJnZSB0b28gbXVjaCBmcm9tIHRoZSBtZXNoIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRoZW0gdG8gYmUgbWVyZ2VkLiBTbyB3ZSBvbmx5IHVwZGF0ZSBhIHNpbmdsZSBjb250b3VyIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhYm92ZSBhbmQgYmVsb3cgdGhlIGV5ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlUmF3Q29vcmRpbmF0ZXMocmF3Q29vcmRzLCBsZWZ0RXllUmF3Q29vcmRzLCAnbGVmdCcsIFsnRXllVXBwZXIwJywgJ0V5ZUxvd2VyMCddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBVc2VyIGlzIGxvb2tpbmcgdG93YXJkcyB0aGUgbGVmdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlUmF3Q29vcmRpbmF0ZXMocmF3Q29vcmRzLCByaWdodEV5ZVJhd0Nvb3JkcywgJ3JpZ2h0JywgWydFeWVVcHBlcjAnLCAnRXllTG93ZXIwJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkanVzdGVkTGVmdElyaXNDb29yZHMgPSBfdGhpcy5nZXRBZGp1c3RlZElyaXNDb29yZHMocmF3Q29vcmRzLCBsZWZ0SXJpc1Jhd0Nvb3JkcywgJ2xlZnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGp1c3RlZFJpZ2h0SXJpc0Nvb3JkcyA9IF90aGlzLmdldEFkanVzdGVkSXJpc0Nvb3JkcyhyYXdDb29yZHMsIHJpZ2h0SXJpc1Jhd0Nvb3JkcywgJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdDb29yZHMgPSByYXdDb29yZHMuY29uY2F0KGFkanVzdGVkTGVmdElyaXNDb29yZHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChhZGp1c3RlZFJpZ2h0SXJpc0Nvb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkQ29vcmRzRGF0YSA9IF90aGlzLnRyYW5zZm9ybVJhd0Nvb3JkcyhyYXdDb29yZHMsIGJveCwgYW5nbGUsIHJvdGF0aW9uTWF0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkQ29vcmRzID0gdGYudGVuc29yMmQodHJhbnNmb3JtZWRDb29yZHNEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmRtYXJrc0JveCA9IGJveF8xLmVubGFyZ2VCb3goX3RoaXMuY2FsY3VsYXRlTGFuZG1hcmtzQm91bmRpbmdCb3godHJhbnNmb3JtZWRDb29yZHNEYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcXVhcmlmaWVkTGFuZG1hcmtzQm94ID0gYm94XzEuc3F1YXJpZnlCb3gobGFuZG1hcmtzQm94KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVnaW9uc09mSW50ZXJlc3RbaV0gPSBfX2Fzc2lnbih7fSwgc3F1YXJpZmllZExhbmRtYXJrc0JveCwgeyBsYW5kbWFya3M6IHRyYW5zZm9ybWVkQ29vcmRzLmFycmF5U3luYygpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZGljdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkczogdGYudGVuc29yMmQocmF3Q29vcmRzLCBbcmF3Q29vcmRzLmxlbmd0aCwgM10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkQ29vcmRzOiB0cmFuc2Zvcm1lZENvb3JkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveDogbGFuZG1hcmtzQm94LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZzogdGYuc3F1ZWV6ZShmbGFnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBVcGRhdGVzIHJlZ2lvbnMgb2YgaW50ZXJlc3QgaWYgdGhlIGludGVyc2VjdGlvbiBvdmVyIHVuaW9uIGJldHdlZW5cbiAgICAvLyB0aGUgaW5jb21pbmcgYW5kIHByZXZpb3VzIHJlZ2lvbnMgZmFsbHMgYmVsb3cgYSB0aHJlc2hvbGQuXG4gICAgUGlwZWxpbmUucHJvdG90eXBlLnVwZGF0ZVJlZ2lvbnNPZkludGVyZXN0ID0gZnVuY3Rpb24gKGJveGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c0JveCA9IHRoaXMucmVnaW9uc09mSW50ZXJlc3RbaV07XG4gICAgICAgICAgICB2YXIgaW91ID0gMDtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0JveCAmJiBwcmV2aW91c0JveC5zdGFydFBvaW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gYm94LnN0YXJ0UG9pbnQsIGJveFN0YXJ0WCA9IF9hWzBdLCBib3hTdGFydFkgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBib3guZW5kUG9pbnQsIGJveEVuZFggPSBfYlswXSwgYm94RW5kWSA9IF9iWzFdO1xuICAgICAgICAgICAgICAgIHZhciBfYyA9IHByZXZpb3VzQm94LnN0YXJ0UG9pbnQsIHByZXZpb3VzQm94U3RhcnRYID0gX2NbMF0sIHByZXZpb3VzQm94U3RhcnRZID0gX2NbMV07XG4gICAgICAgICAgICAgICAgdmFyIF9kID0gcHJldmlvdXNCb3guZW5kUG9pbnQsIHByZXZpb3VzQm94RW5kWCA9IF9kWzBdLCBwcmV2aW91c0JveEVuZFkgPSBfZFsxXTtcbiAgICAgICAgICAgICAgICB2YXIgeFN0YXJ0TWF4ID0gTWF0aC5tYXgoYm94U3RhcnRYLCBwcmV2aW91c0JveFN0YXJ0WCk7XG4gICAgICAgICAgICAgICAgdmFyIHlTdGFydE1heCA9IE1hdGgubWF4KGJveFN0YXJ0WSwgcHJldmlvdXNCb3hTdGFydFkpO1xuICAgICAgICAgICAgICAgIHZhciB4RW5kTWluID0gTWF0aC5taW4oYm94RW5kWCwgcHJldmlvdXNCb3hFbmRYKTtcbiAgICAgICAgICAgICAgICB2YXIgeUVuZE1pbiA9IE1hdGgubWluKGJveEVuZFksIHByZXZpb3VzQm94RW5kWSk7XG4gICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9ICh4RW5kTWluIC0geFN0YXJ0TWF4KSAqICh5RW5kTWluIC0geVN0YXJ0TWF4KTtcbiAgICAgICAgICAgICAgICB2YXIgYm94QXJlYSA9IChib3hFbmRYIC0gYm94U3RhcnRYKSAqIChib3hFbmRZIC0gYm94U3RhcnRZKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNCb3hBcmVhID0gKHByZXZpb3VzQm94RW5kWCAtIHByZXZpb3VzQm94U3RhcnRYKSAqXG4gICAgICAgICAgICAgICAgICAgIChwcmV2aW91c0JveEVuZFkgLSBib3hTdGFydFkpO1xuICAgICAgICAgICAgICAgIGlvdSA9IGludGVyc2VjdGlvbiAvIChib3hBcmVhICsgcHJldmlvdXNCb3hBcmVhIC0gaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpb3UgPCBVUERBVEVfUkVHSU9OX09GX0lOVEVSRVNUX0lPVV9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lvbnNPZkludGVyZXN0W2ldID0gYm94O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVnaW9uc09mSW50ZXJlc3QgPSB0aGlzLnJlZ2lvbnNPZkludGVyZXN0LnNsaWNlKDAsIGJveGVzLmxlbmd0aCk7XG4gICAgfTtcbiAgICBQaXBlbGluZS5wcm90b3R5cGUuY2xlYXJSZWdpb25PZkludGVyZXN0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnJlZ2lvbnNPZkludGVyZXN0W2luZGV4XSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lvbnNPZkludGVyZXN0ID0gdGhpcy5yZWdpb25zT2ZJbnRlcmVzdC5zbGljZSgwLCBpbmRleCkuY29uY2F0KHRoaXMucmVnaW9uc09mSW50ZXJlc3Quc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBpcGVsaW5lLnByb3RvdHlwZS5zaG91bGRVcGRhdGVSZWdpb25zT2ZJbnRlcmVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvaXNDb3VudCA9IHRoaXMucmVnaW9uc09mSW50ZXJlc3QubGVuZ3RoO1xuICAgICAgICB2YXIgbm9ST0lzID0gcm9pc0NvdW50ID09PSAwO1xuICAgICAgICBpZiAodGhpcy5tYXhGYWNlcyA9PT0gMSB8fCBub1JPSXMpIHtcbiAgICAgICAgICAgIHJldHVybiBub1JPSXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvaXNDb3VudCAhPT0gdGhpcy5tYXhGYWNlcyAmJlxuICAgICAgICAgICAgdGhpcy5ydW5zV2l0aG91dEZhY2VEZXRlY3RvciA+PSB0aGlzLm1heENvbnRpbnVvdXNDaGVja3M7XG4gICAgfTtcbiAgICBQaXBlbGluZS5wcm90b3R5cGUuY2FsY3VsYXRlTGFuZG1hcmtzQm91bmRpbmdCb3ggPSBmdW5jdGlvbiAobGFuZG1hcmtzKSB7XG4gICAgICAgIHZhciB4cyA9IGxhbmRtYXJrcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbMF07IH0pO1xuICAgICAgICB2YXIgeXMgPSBsYW5kbWFya3MubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWzFdOyB9KTtcbiAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSBbTWF0aC5taW4uYXBwbHkoTWF0aCwgeHMpLCBNYXRoLm1pbi5hcHBseShNYXRoLCB5cyldO1xuICAgICAgICB2YXIgZW5kUG9pbnQgPSBbTWF0aC5tYXguYXBwbHkoTWF0aCwgeHMpLCBNYXRoLm1heC5hcHBseShNYXRoLCB5cyldO1xuICAgICAgICByZXR1cm4geyBzdGFydFBvaW50OiBzdGFydFBvaW50LCBlbmRQb2ludDogZW5kUG9pbnQgfTtcbiAgICB9O1xuICAgIHJldHVybiBQaXBlbGluZTtcbn0oKSk7XG5leHBvcnRzLlBpcGVsaW5lID0gUGlwZWxpbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1waXBlbGluZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/pipeline.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/util.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/util.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IDENTITY_MATRIX = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\n/**\n * Normalizes the provided angle to the range -pi to pi.\n * @param angle The angle in radians to be normalized.\n */\nfunction normalizeRadians(angle) {\n    return angle - 2 * Math.PI * Math.floor((angle + Math.PI) / (2 * Math.PI));\n}\nexports.normalizeRadians = normalizeRadians;\n/**\n * Computes the angle of rotation between two anchor points.\n * @param point1 First anchor point\n * @param point2 Second anchor point\n */\nfunction computeRotation(point1, point2) {\n    var radians = Math.PI / 2 - Math.atan2(-(point2[1] - point1[1]), point2[0] - point1[0]);\n    return normalizeRadians(radians);\n}\nexports.computeRotation = computeRotation;\nfunction radToDegrees(rad) {\n    return rad * 180 / Math.PI;\n}\nexports.radToDegrees = radToDegrees;\nfunction buildTranslationMatrix(x, y) {\n    return [[1, 0, x], [0, 1, y], [0, 0, 1]];\n}\nfunction dot(v1, v2) {\n    var product = 0;\n    for (var i = 0; i < v1.length; i++) {\n        product += v1[i] * v2[i];\n    }\n    return product;\n}\nexports.dot = dot;\nfunction getColumnFrom2DArr(arr, columnIndex) {\n    var column = [];\n    for (var i = 0; i < arr.length; i++) {\n        column.push(arr[i][columnIndex]);\n    }\n    return column;\n}\nexports.getColumnFrom2DArr = getColumnFrom2DArr;\nfunction multiplyTransformMatrices(mat1, mat2) {\n    var product = [];\n    var size = mat1.length;\n    for (var row = 0; row < size; row++) {\n        product.push([]);\n        for (var col = 0; col < size; col++) {\n            product[row].push(dot(mat1[row], getColumnFrom2DArr(mat2, col)));\n        }\n    }\n    return product;\n}\nfunction buildRotationMatrix(rotation, center) {\n    var cosA = Math.cos(rotation);\n    var sinA = Math.sin(rotation);\n    var rotationMatrix = [[cosA, -sinA, 0], [sinA, cosA, 0], [0, 0, 1]];\n    var translationMatrix = buildTranslationMatrix(center[0], center[1]);\n    var translationTimesRotation = multiplyTransformMatrices(translationMatrix, rotationMatrix);\n    var negativeTranslationMatrix = buildTranslationMatrix(-center[0], -center[1]);\n    return multiplyTransformMatrices(translationTimesRotation, negativeTranslationMatrix);\n}\nexports.buildRotationMatrix = buildRotationMatrix;\nfunction invertTransformMatrix(matrix) {\n    var rotationComponent = [[matrix[0][0], matrix[1][0]], [matrix[0][1], matrix[1][1]]];\n    var translationComponent = [matrix[0][2], matrix[1][2]];\n    var invertedTranslation = [\n        -dot(rotationComponent[0], translationComponent),\n        -dot(rotationComponent[1], translationComponent)\n    ];\n    return [\n        rotationComponent[0].concat(invertedTranslation[0]),\n        rotationComponent[1].concat(invertedTranslation[1]), [0, 0, 1]\n    ];\n}\nexports.invertTransformMatrix = invertTransformMatrix;\nfunction rotatePoint(homogeneousCoordinate, rotationMatrix) {\n    return [\n        dot(homogeneousCoordinate, rotationMatrix[0]),\n        dot(homogeneousCoordinate, rotationMatrix[1])\n    ];\n}\nexports.rotatePoint = rotatePoint;\nfunction xyDistanceBetweenPoints(a, b) {\n    return Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));\n}\nexports.xyDistanceBetweenPoints = xyDistanceBetweenPoints;\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3ctbW9kZWxzL2ZhY2UtbGFuZG1hcmtzLWRldGVjdGlvbi9kaXN0L21lZGlhcGlwZS1mYWNlbWVzaC91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWVjb21tZXJjZS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93LW1vZGVscy9mYWNlLWxhbmRtYXJrcy1kZXRlY3Rpb24vZGlzdC9tZWRpYXBpcGUtZmFjZW1lc2gvdXRpbC5qcz8wYmRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSURFTlRJVFlfTUFUUklYID0gW1sxLCAwLCAwXSwgWzAsIDEsIDBdLCBbMCwgMCwgMV1dO1xuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSBwcm92aWRlZCBhbmdsZSB0byB0aGUgcmFuZ2UgLXBpIHRvIHBpLlxuICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBpbiByYWRpYW5zIHRvIGJlIG5vcm1hbGl6ZWQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJhZGlhbnMoYW5nbGUpIHtcbiAgICByZXR1cm4gYW5nbGUgLSAyICogTWF0aC5QSSAqIE1hdGguZmxvb3IoKGFuZ2xlICsgTWF0aC5QSSkgLyAoMiAqIE1hdGguUEkpKTtcbn1cbmV4cG9ydHMubm9ybWFsaXplUmFkaWFucyA9IG5vcm1hbGl6ZVJhZGlhbnM7XG4vKipcbiAqIENvbXB1dGVzIHRoZSBhbmdsZSBvZiByb3RhdGlvbiBiZXR3ZWVuIHR3byBhbmNob3IgcG9pbnRzLlxuICogQHBhcmFtIHBvaW50MSBGaXJzdCBhbmNob3IgcG9pbnRcbiAqIEBwYXJhbSBwb2ludDIgU2Vjb25kIGFuY2hvciBwb2ludFxuICovXG5mdW5jdGlvbiBjb21wdXRlUm90YXRpb24ocG9pbnQxLCBwb2ludDIpIHtcbiAgICB2YXIgcmFkaWFucyA9IE1hdGguUEkgLyAyIC0gTWF0aC5hdGFuMigtKHBvaW50MlsxXSAtIHBvaW50MVsxXSksIHBvaW50MlswXSAtIHBvaW50MVswXSk7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVJhZGlhbnMocmFkaWFucyk7XG59XG5leHBvcnRzLmNvbXB1dGVSb3RhdGlvbiA9IGNvbXB1dGVSb3RhdGlvbjtcbmZ1bmN0aW9uIHJhZFRvRGVncmVlcyhyYWQpIHtcbiAgICByZXR1cm4gcmFkICogMTgwIC8gTWF0aC5QSTtcbn1cbmV4cG9ydHMucmFkVG9EZWdyZWVzID0gcmFkVG9EZWdyZWVzO1xuZnVuY3Rpb24gYnVpbGRUcmFuc2xhdGlvbk1hdHJpeCh4LCB5KSB7XG4gICAgcmV0dXJuIFtbMSwgMCwgeF0sIFswLCAxLCB5XSwgWzAsIDAsIDFdXTtcbn1cbmZ1bmN0aW9uIGRvdCh2MSwgdjIpIHtcbiAgICB2YXIgcHJvZHVjdCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcm9kdWN0ICs9IHYxW2ldICogdjJbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9kdWN0O1xufVxuZXhwb3J0cy5kb3QgPSBkb3Q7XG5mdW5jdGlvbiBnZXRDb2x1bW5Gcm9tMkRBcnIoYXJyLCBjb2x1bW5JbmRleCkge1xuICAgIHZhciBjb2x1bW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb2x1bW4ucHVzaChhcnJbaV1bY29sdW1uSW5kZXhdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbHVtbjtcbn1cbmV4cG9ydHMuZ2V0Q29sdW1uRnJvbTJEQXJyID0gZ2V0Q29sdW1uRnJvbTJEQXJyO1xuZnVuY3Rpb24gbXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyhtYXQxLCBtYXQyKSB7XG4gICAgdmFyIHByb2R1Y3QgPSBbXTtcbiAgICB2YXIgc2l6ZSA9IG1hdDEubGVuZ3RoO1xuICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHNpemU7IHJvdysrKSB7XG4gICAgICAgIHByb2R1Y3QucHVzaChbXSk7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHNpemU7IGNvbCsrKSB7XG4gICAgICAgICAgICBwcm9kdWN0W3Jvd10ucHVzaChkb3QobWF0MVtyb3ddLCBnZXRDb2x1bW5Gcm9tMkRBcnIobWF0MiwgY29sKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9kdWN0O1xufVxuZnVuY3Rpb24gYnVpbGRSb3RhdGlvbk1hdHJpeChyb3RhdGlvbiwgY2VudGVyKSB7XG4gICAgdmFyIGNvc0EgPSBNYXRoLmNvcyhyb3RhdGlvbik7XG4gICAgdmFyIHNpbkEgPSBNYXRoLnNpbihyb3RhdGlvbik7XG4gICAgdmFyIHJvdGF0aW9uTWF0cml4ID0gW1tjb3NBLCAtc2luQSwgMF0sIFtzaW5BLCBjb3NBLCAwXSwgWzAsIDAsIDFdXTtcbiAgICB2YXIgdHJhbnNsYXRpb25NYXRyaXggPSBidWlsZFRyYW5zbGF0aW9uTWF0cml4KGNlbnRlclswXSwgY2VudGVyWzFdKTtcbiAgICB2YXIgdHJhbnNsYXRpb25UaW1lc1JvdGF0aW9uID0gbXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyh0cmFuc2xhdGlvbk1hdHJpeCwgcm90YXRpb25NYXRyaXgpO1xuICAgIHZhciBuZWdhdGl2ZVRyYW5zbGF0aW9uTWF0cml4ID0gYnVpbGRUcmFuc2xhdGlvbk1hdHJpeCgtY2VudGVyWzBdLCAtY2VudGVyWzFdKTtcbiAgICByZXR1cm4gbXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyh0cmFuc2xhdGlvblRpbWVzUm90YXRpb24sIG5lZ2F0aXZlVHJhbnNsYXRpb25NYXRyaXgpO1xufVxuZXhwb3J0cy5idWlsZFJvdGF0aW9uTWF0cml4ID0gYnVpbGRSb3RhdGlvbk1hdHJpeDtcbmZ1bmN0aW9uIGludmVydFRyYW5zZm9ybU1hdHJpeChtYXRyaXgpIHtcbiAgICB2YXIgcm90YXRpb25Db21wb25lbnQgPSBbW21hdHJpeFswXVswXSwgbWF0cml4WzFdWzBdXSwgW21hdHJpeFswXVsxXSwgbWF0cml4WzFdWzFdXV07XG4gICAgdmFyIHRyYW5zbGF0aW9uQ29tcG9uZW50ID0gW21hdHJpeFswXVsyXSwgbWF0cml4WzFdWzJdXTtcbiAgICB2YXIgaW52ZXJ0ZWRUcmFuc2xhdGlvbiA9IFtcbiAgICAgICAgLWRvdChyb3RhdGlvbkNvbXBvbmVudFswXSwgdHJhbnNsYXRpb25Db21wb25lbnQpLFxuICAgICAgICAtZG90KHJvdGF0aW9uQ29tcG9uZW50WzFdLCB0cmFuc2xhdGlvbkNvbXBvbmVudClcbiAgICBdO1xuICAgIHJldHVybiBbXG4gICAgICAgIHJvdGF0aW9uQ29tcG9uZW50WzBdLmNvbmNhdChpbnZlcnRlZFRyYW5zbGF0aW9uWzBdKSxcbiAgICAgICAgcm90YXRpb25Db21wb25lbnRbMV0uY29uY2F0KGludmVydGVkVHJhbnNsYXRpb25bMV0pLCBbMCwgMCwgMV1cbiAgICBdO1xufVxuZXhwb3J0cy5pbnZlcnRUcmFuc2Zvcm1NYXRyaXggPSBpbnZlcnRUcmFuc2Zvcm1NYXRyaXg7XG5mdW5jdGlvbiByb3RhdGVQb2ludChob21vZ2VuZW91c0Nvb3JkaW5hdGUsIHJvdGF0aW9uTWF0cml4KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZG90KGhvbW9nZW5lb3VzQ29vcmRpbmF0ZSwgcm90YXRpb25NYXRyaXhbMF0pLFxuICAgICAgICBkb3QoaG9tb2dlbmVvdXNDb29yZGluYXRlLCByb3RhdGlvbk1hdHJpeFsxXSlcbiAgICBdO1xufVxuZXhwb3J0cy5yb3RhdGVQb2ludCA9IHJvdGF0ZVBvaW50O1xuZnVuY3Rpb24geHlEaXN0YW5jZUJldHdlZW5Qb2ludHMoYSwgYikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coYVswXSAtIGJbMF0sIDIpICsgTWF0aC5wb3coYVsxXSAtIGJbMV0sIDIpKTtcbn1cbmV4cG9ydHMueHlEaXN0YW5jZUJldHdlZW5Qb2ludHMgPSB4eURpc3RhbmNlQmV0d2VlblBvaW50cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/uv_coords.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/uv_coords.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UV_COORDS = [\n    [0.499976992607117, 0.652534008026123],\n    [0.500025987625122, 0.547487020492554],\n    [0.499974012374878, 0.602371990680695],\n    [0.482113003730774, 0.471979022026062],\n    [0.500150978565216, 0.527155995368958],\n    [0.499909996986389, 0.498252987861633],\n    [0.499523013830185, 0.40106201171875],\n    [0.289712011814117, 0.380764007568359],\n    [0.499954998493195, 0.312398016452789],\n    [0.499987006187439, 0.269918978214264],\n    [0.500023007392883, 0.107050001621246],\n    [0.500023007392883, 0.666234016418457],\n    [0.5000159740448, 0.679224014282227],\n    [0.500023007392883, 0.692348003387451],\n    [0.499976992607117, 0.695277988910675],\n    [0.499976992607117, 0.70593398809433],\n    [0.499976992607117, 0.719385027885437],\n    [0.499976992607117, 0.737019002437592],\n    [0.499967992305756, 0.781370997428894],\n    [0.499816000461578, 0.562981009483337],\n    [0.473773002624512, 0.573909997940063],\n    [0.104906998574734, 0.254140973091125],\n    [0.365929991006851, 0.409575998783112],\n    [0.338757991790771, 0.41302502155304],\n    [0.311120003461838, 0.409460008144379],\n    [0.274657994508743, 0.389131009578705],\n    [0.393361985683441, 0.403706014156342],\n    [0.345234006643295, 0.344011008739471],\n    [0.370094001293182, 0.346076011657715],\n    [0.319321990013123, 0.347265005111694],\n    [0.297903001308441, 0.353591024875641],\n    [0.24779200553894, 0.410809993743896],\n    [0.396889001131058, 0.842755019664764],\n    [0.280097991228104, 0.375599980354309],\n    [0.106310002505779, 0.399955987930298],\n    [0.2099249958992, 0.391353011131287],\n    [0.355807989835739, 0.534406006336212],\n    [0.471751004457474, 0.65040397644043],\n    [0.474155008792877, 0.680191993713379],\n    [0.439785003662109, 0.657229006290436],\n    [0.414617002010345, 0.66654098033905],\n    [0.450374007225037, 0.680860996246338],\n    [0.428770989179611, 0.682690978050232],\n    [0.374971002340317, 0.727805018424988],\n    [0.486716985702515, 0.547628998756409],\n    [0.485300987958908, 0.527395009994507],\n    [0.257764995098114, 0.314490020275116],\n    [0.401223003864288, 0.455172002315521],\n    [0.429818987846375, 0.548614978790283],\n    [0.421351999044418, 0.533740997314453],\n    [0.276895999908447, 0.532056987285614],\n    [0.483370006084442, 0.499586999416351],\n    [0.33721199631691, 0.282882988452911],\n    [0.296391993761063, 0.293242990970612],\n    [0.169294998049736, 0.193813979625702],\n    [0.447580009698868, 0.302609980106354],\n    [0.392390012741089, 0.353887975215912],\n    [0.354490011930466, 0.696784019470215],\n    [0.067304998636246, 0.730105042457581],\n    [0.442739009857178, 0.572826027870178],\n    [0.457098007202148, 0.584792017936707],\n    [0.381974011659622, 0.694710969924927],\n    [0.392388999462128, 0.694203019142151],\n    [0.277076005935669, 0.271932005882263],\n    [0.422551989555359, 0.563233017921448],\n    [0.385919004678726, 0.281364023685455],\n    [0.383103013038635, 0.255840003490448],\n    [0.331431001424789, 0.119714021682739],\n    [0.229923993349075, 0.232002973556519],\n    [0.364500999450684, 0.189113974571228],\n    [0.229622006416321, 0.299540996551514],\n    [0.173287004232407, 0.278747975826263],\n    [0.472878992557526, 0.666198015213013],\n    [0.446828007698059, 0.668527007102966],\n    [0.422762006521225, 0.673889994621277],\n    [0.445307999849319, 0.580065965652466],\n    [0.388103008270264, 0.693961024284363],\n    [0.403039008378983, 0.706539988517761],\n    [0.403629004955292, 0.693953037261963],\n    [0.460041999816895, 0.557139039039612],\n    [0.431158006191254, 0.692366003990173],\n    [0.452181994915009, 0.692366003990173],\n    [0.475387006998062, 0.692366003990173],\n    [0.465828001499176, 0.779190003871918],\n    [0.472328990697861, 0.736225962638855],\n    [0.473087012767792, 0.717857003211975],\n    [0.473122000694275, 0.704625964164734],\n    [0.473033010959625, 0.695277988910675],\n    [0.427942007780075, 0.695277988910675],\n    [0.426479011774063, 0.703539967536926],\n    [0.423162013292313, 0.711845993995667],\n    [0.4183090031147, 0.720062971115112],\n    [0.390094995498657, 0.639572978019714],\n    [0.013953999616206, 0.560034036636353],\n    [0.499913990497589, 0.58014702796936],\n    [0.413199990987778, 0.69539999961853],\n    [0.409626007080078, 0.701822996139526],\n    [0.468080013990402, 0.601534962654114],\n    [0.422728985548019, 0.585985004901886],\n    [0.463079988956451, 0.593783974647522],\n    [0.37211999297142, 0.47341400384903],\n    [0.334562003612518, 0.496073007583618],\n    [0.411671012639999, 0.546965003013611],\n    [0.242175996303558, 0.14767599105835],\n    [0.290776997804642, 0.201445996761322],\n    [0.327338010072708, 0.256527006626129],\n    [0.399509996175766, 0.748921036720276],\n    [0.441727995872498, 0.261676013469696],\n    [0.429764986038208, 0.187834024429321],\n    [0.412198007106781, 0.108901023864746],\n    [0.288955003023148, 0.398952007293701],\n    [0.218936994671822, 0.435410976409912],\n    [0.41278201341629, 0.398970007896423],\n    [0.257135003805161, 0.355440020561218],\n    [0.427684992551804, 0.437960982322693],\n    [0.448339998722076, 0.536936044692993],\n    [0.178560003638268, 0.45755398273468],\n    [0.247308000922203, 0.457193970680237],\n    [0.286267012357712, 0.467674970626831],\n    [0.332827985286713, 0.460712015628815],\n    [0.368755996227264, 0.447206974029541],\n    [0.398963987827301, 0.432654976844788],\n    [0.476410001516342, 0.405806005001068],\n    [0.189241006970406, 0.523923993110657],\n    [0.228962004184723, 0.348950982093811],\n    [0.490725994110107, 0.562400996685028],\n    [0.404670000076294, 0.485132992267609],\n    [0.019469000399113, 0.401564002037048],\n    [0.426243007183075, 0.420431017875671],\n    [0.396993011236191, 0.548797011375427],\n    [0.266469985246658, 0.376977026462555],\n    [0.439121007919312, 0.51895797252655],\n    [0.032313998788595, 0.644356966018677],\n    [0.419054001569748, 0.387154996395111],\n    [0.462783008813858, 0.505746960639954],\n    [0.238978996872902, 0.779744982719421],\n    [0.198220998048782, 0.831938028335571],\n    [0.107550002634525, 0.540755033493042],\n    [0.183610007166862, 0.740257024765015],\n    [0.134409993886948, 0.333683013916016],\n    [0.385764002799988, 0.883153975009918],\n    [0.490967005491257, 0.579378008842468],\n    [0.382384985685349, 0.508572995662689],\n    [0.174399003386497, 0.397670984268188],\n    [0.318785011768341, 0.39623498916626],\n    [0.343364000320435, 0.400596976280212],\n    [0.396100014448166, 0.710216999053955],\n    [0.187885001301765, 0.588537991046906],\n    [0.430987000465393, 0.944064974784851],\n    [0.318993002176285, 0.898285031318665],\n    [0.266247987747192, 0.869701027870178],\n    [0.500023007392883, 0.190576016902924],\n    [0.499976992607117, 0.954452991485596],\n    [0.366169989109039, 0.398822009563446],\n    [0.393207013607025, 0.39553701877594],\n    [0.410373002290726, 0.391080021858215],\n    [0.194993004202843, 0.342101991176605],\n    [0.388664990663528, 0.362284004688263],\n    [0.365961998701096, 0.355970978736877],\n    [0.343364000320435, 0.355356991291046],\n    [0.318785011768341, 0.35834002494812],\n    [0.301414996385574, 0.363156020641327],\n    [0.058132998645306, 0.319076001644135],\n    [0.301414996385574, 0.387449026107788],\n    [0.499987989664078, 0.618434011936188],\n    [0.415838003158569, 0.624195992946625],\n    [0.445681989192963, 0.566076993942261],\n    [0.465844005346298, 0.620640993118286],\n    [0.49992299079895, 0.351523995399475],\n    [0.288718998432159, 0.819945991039276],\n    [0.335278987884521, 0.852819979190826],\n    [0.440512001514435, 0.902418971061707],\n    [0.128294005990028, 0.791940987110138],\n    [0.408771991729736, 0.373893976211548],\n    [0.455606997013092, 0.451801002025604],\n    [0.499877005815506, 0.908990025520325],\n    [0.375436991453171, 0.924192011356354],\n    [0.11421000212431, 0.615022003650665],\n    [0.448662012815475, 0.695277988910675],\n    [0.4480200111866, 0.704632043838501],\n    [0.447111994028091, 0.715808033943176],\n    [0.444831997156143, 0.730794012546539],\n    [0.430011987686157, 0.766808986663818],\n    [0.406787008047104, 0.685672998428345],\n    [0.400738000869751, 0.681069016456604],\n    [0.392399996519089, 0.677703022956848],\n    [0.367855995893478, 0.663918972015381],\n    [0.247923001646996, 0.601333022117615],\n    [0.452769994735718, 0.420849978923798],\n    [0.43639200925827, 0.359887003898621],\n    [0.416164010763168, 0.368713974952698],\n    [0.413385987281799, 0.692366003990173],\n    [0.228018000721931, 0.683571994304657],\n    [0.468268007040024, 0.352671027183533],\n    [0.411361992359161, 0.804327011108398],\n    [0.499989002943039, 0.469825029373169],\n    [0.479153990745544, 0.442654013633728],\n    [0.499974012374878, 0.439637005329132],\n    [0.432112008333206, 0.493588984012604],\n    [0.499886006116867, 0.866917014122009],\n    [0.49991300702095, 0.821729004383087],\n    [0.456548988819122, 0.819200992584229],\n    [0.344549000263214, 0.745438992977142],\n    [0.37890899181366, 0.574010014533997],\n    [0.374292999505997, 0.780184984207153],\n    [0.319687992334366, 0.570737957954407],\n    [0.357154995203018, 0.604269981384277],\n    [0.295284003019333, 0.621580958366394],\n    [0.447750002145767, 0.862477004528046],\n    [0.410986006259918, 0.508723020553589],\n    [0.31395098567009, 0.775308012962341],\n    [0.354128003120422, 0.812552988529205],\n    [0.324548006057739, 0.703992962837219],\n    [0.189096003770828, 0.646299958229065],\n    [0.279776990413666, 0.71465802192688],\n    [0.1338230073452, 0.682700991630554],\n    [0.336768001317978, 0.644733011722565],\n    [0.429883986711502, 0.466521978378296],\n    [0.455527991056442, 0.548622965812683],\n    [0.437114000320435, 0.558896005153656],\n    [0.467287987470627, 0.529924988746643],\n    [0.414712011814117, 0.335219979286194],\n    [0.37704598903656, 0.322777986526489],\n    [0.344107985496521, 0.320150971412659],\n    [0.312875986099243, 0.32233202457428],\n    [0.283526003360748, 0.333190023899078],\n    [0.241245999932289, 0.382785975933075],\n    [0.102986000478268, 0.468762993812561],\n    [0.267612010240555, 0.424560010433197],\n    [0.297879010438919, 0.433175981044769],\n    [0.333433985710144, 0.433878004550934],\n    [0.366427004337311, 0.426115989685059],\n    [0.396012008190155, 0.416696012020111],\n    [0.420121014118195, 0.41022801399231],\n    [0.007561000064015, 0.480777025222778],\n    [0.432949006557465, 0.569517970085144],\n    [0.458638995885849, 0.479089021682739],\n    [0.473466008901596, 0.545744001865387],\n    [0.476087987422943, 0.563830018043518],\n    [0.468472003936768, 0.555056989192963],\n    [0.433990985155106, 0.582361996173859],\n    [0.483518004417419, 0.562983989715576],\n    [0.482482999563217, 0.57784903049469],\n    [0.42645001411438, 0.389798998832703],\n    [0.438998997211456, 0.39649498462677],\n    [0.450067013502121, 0.400434017181396],\n    [0.289712011814117, 0.368252992630005],\n    [0.276670008897781, 0.363372981548309],\n    [0.517862021923065, 0.471948027610779],\n    [0.710287988185883, 0.380764007568359],\n    [0.526226997375488, 0.573909997940063],\n    [0.895093023777008, 0.254140973091125],\n    [0.634069979190826, 0.409575998783112],\n    [0.661242008209229, 0.41302502155304],\n    [0.688880026340485, 0.409460008144379],\n    [0.725341975688934, 0.389131009578705],\n    [0.606630027294159, 0.40370500087738],\n    [0.654766023159027, 0.344011008739471],\n    [0.629905998706818, 0.346076011657715],\n    [0.680678009986877, 0.347265005111694],\n    [0.702096998691559, 0.353591024875641],\n    [0.75221198797226, 0.410804986953735],\n    [0.602918028831482, 0.842862963676453],\n    [0.719901978969574, 0.375599980354309],\n    [0.893692970275879, 0.399959981441498],\n    [0.790081977844238, 0.391354024410248],\n    [0.643998026847839, 0.534487962722778],\n    [0.528249025344849, 0.65040397644043],\n    [0.525849997997284, 0.680191040039062],\n    [0.560214996337891, 0.657229006290436],\n    [0.585384011268616, 0.66654098033905],\n    [0.549625992774963, 0.680860996246338],\n    [0.57122802734375, 0.682691991329193],\n    [0.624852001667023, 0.72809898853302],\n    [0.513050019741058, 0.547281980514526],\n    [0.51509702205658, 0.527251958847046],\n    [0.742246985435486, 0.314507007598877],\n    [0.598631024360657, 0.454979002475739],\n    [0.570338010787964, 0.548575043678284],\n    [0.578631997108459, 0.533622980117798],\n    [0.723087012767792, 0.532054007053375],\n    [0.516445994377136, 0.499638974666595],\n    [0.662801027297974, 0.282917976379395],\n    [0.70362401008606, 0.293271005153656],\n    [0.830704987049103, 0.193813979625702],\n    [0.552385985851288, 0.302568018436432],\n    [0.607609987258911, 0.353887975215912],\n    [0.645429015159607, 0.696707010269165],\n    [0.932694971561432, 0.730105042457581],\n    [0.557260990142822, 0.572826027870178],\n    [0.542901992797852, 0.584792017936707],\n    [0.6180260181427, 0.694710969924927],\n    [0.607590973377228, 0.694203019142151],\n    [0.722943007946014, 0.271963000297546],\n    [0.577413976192474, 0.563166975975037],\n    [0.614082992076874, 0.281386971473694],\n    [0.616907000541687, 0.255886018276215],\n    [0.668509006500244, 0.119913995265961],\n    [0.770092010498047, 0.232020974159241],\n    [0.635536015033722, 0.189248979091644],\n    [0.77039098739624, 0.299556016921997],\n    [0.826722025871277, 0.278755009174347],\n    [0.527121007442474, 0.666198015213013],\n    [0.553171992301941, 0.668527007102966],\n    [0.577238023281097, 0.673889994621277],\n    [0.554691970348358, 0.580065965652466],\n    [0.611896991729736, 0.693961024284363],\n    [0.59696102142334, 0.706539988517761],\n    [0.596370995044708, 0.693953037261963],\n    [0.539958000183105, 0.557139039039612],\n    [0.568841993808746, 0.692366003990173],\n    [0.547818005084991, 0.692366003990173],\n    [0.52461302280426, 0.692366003990173],\n    [0.534089982509613, 0.779141008853912],\n    [0.527670979499817, 0.736225962638855],\n    [0.526912987232208, 0.717857003211975],\n    [0.526877999305725, 0.704625964164734],\n    [0.526966989040375, 0.695277988910675],\n    [0.572058022022247, 0.695277988910675],\n    [0.573521018028259, 0.703539967536926],\n    [0.57683801651001, 0.711845993995667],\n    [0.581691026687622, 0.720062971115112],\n    [0.609944999217987, 0.639909982681274],\n    [0.986046016216278, 0.560034036636353],\n    [0.5867999792099, 0.69539999961853],\n    [0.590372025966644, 0.701822996139526],\n    [0.531915009021759, 0.601536989212036],\n    [0.577268004417419, 0.585934996604919],\n    [0.536915004253387, 0.593786001205444],\n    [0.627542972564697, 0.473352015018463],\n    [0.665585994720459, 0.495950996875763],\n    [0.588353991508484, 0.546862006187439],\n    [0.757824003696442, 0.14767599105835],\n    [0.709249973297119, 0.201507985591888],\n    [0.672684013843536, 0.256581008434296],\n    [0.600408971309662, 0.74900496006012],\n    [0.55826598405838, 0.261672019958496],\n    [0.570303976535797, 0.187870979309082],\n    [0.588165998458862, 0.109044015407562],\n    [0.711045026779175, 0.398952007293701],\n    [0.781069993972778, 0.435405015945435],\n    [0.587247014045715, 0.398931980133057],\n    [0.742869973182678, 0.355445981025696],\n    [0.572156012058258, 0.437651991844177],\n    [0.55186802148819, 0.536570012569427],\n    [0.821442008018494, 0.457556009292603],\n    [0.752701997756958, 0.457181990146637],\n    [0.71375697851181, 0.467626988887787],\n    [0.66711300611496, 0.460672974586487],\n    [0.631101012229919, 0.447153985500336],\n    [0.6008620262146, 0.432473003864288],\n    [0.523481011390686, 0.405627012252808],\n    [0.810747981071472, 0.523926019668579],\n    [0.771045982837677, 0.348959028720856],\n    [0.509127020835876, 0.562718033790588],\n    [0.595292985439301, 0.485023975372314],\n    [0.980530977249146, 0.401564002037048],\n    [0.573499977588654, 0.420000016689301],\n    [0.602994978427887, 0.548687994480133],\n    [0.733529984951019, 0.376977026462555],\n    [0.560611009597778, 0.519016981124878],\n    [0.967685997486115, 0.644356966018677],\n    [0.580985009670258, 0.387160003185272],\n    [0.537728011608124, 0.505385041236877],\n    [0.760966002941132, 0.779752969741821],\n    [0.801778972148895, 0.831938028335571],\n    [0.892440974712372, 0.54076099395752],\n    [0.816350996494293, 0.740260004997253],\n    [0.865594983100891, 0.333687007427216],\n    [0.614073991775513, 0.883246004581451],\n    [0.508952975273132, 0.579437971115112],\n    [0.617941975593567, 0.508316040039062],\n    [0.825608015060425, 0.397674977779388],\n    [0.681214988231659, 0.39623498916626],\n    [0.656635999679565, 0.400596976280212],\n    [0.603900015354156, 0.710216999053955],\n    [0.81208598613739, 0.588539004325867],\n    [0.56801301240921, 0.944564998149872],\n    [0.681007981300354, 0.898285031318665],\n    [0.733752012252808, 0.869701027870178],\n    [0.633830010890961, 0.398822009563446],\n    [0.606792986392975, 0.39553701877594],\n    [0.589659988880157, 0.391062021255493],\n    [0.805015981197357, 0.342108011245728],\n    [0.611334979534149, 0.362284004688263],\n    [0.634037971496582, 0.355970978736877],\n    [0.656635999679565, 0.355356991291046],\n    [0.681214988231659, 0.35834002494812],\n    [0.698584973812103, 0.363156020641327],\n    [0.941866993904114, 0.319076001644135],\n    [0.698584973812103, 0.387449026107788],\n    [0.584177017211914, 0.624107003211975],\n    [0.554318010807037, 0.566076993942261],\n    [0.534153997898102, 0.62064003944397],\n    [0.711217999458313, 0.819975018501282],\n    [0.664629995822906, 0.852871000766754],\n    [0.559099972248077, 0.902631998062134],\n    [0.871706008911133, 0.791940987110138],\n    [0.591234028339386, 0.373893976211548],\n    [0.544341027736664, 0.451583981513977],\n    [0.624562978744507, 0.924192011356354],\n    [0.88577002286911, 0.615028977394104],\n    [0.551338016986847, 0.695277988910675],\n    [0.551980018615723, 0.704632043838501],\n    [0.552887976169586, 0.715808033943176],\n    [0.555167973041534, 0.730794012546539],\n    [0.569944024085999, 0.767035007476807],\n    [0.593203008174896, 0.685675978660583],\n    [0.599261999130249, 0.681069016456604],\n    [0.607599973678589, 0.677703022956848],\n    [0.631937980651855, 0.663500010967255],\n    [0.752032995223999, 0.601315021514893],\n    [0.547226011753082, 0.420395016670227],\n    [0.563543975353241, 0.359827995300293],\n    [0.583841025829315, 0.368713974952698],\n    [0.586614012718201, 0.692366003990173],\n    [0.771915018558502, 0.683578014373779],\n    [0.531597018241882, 0.352482974529266],\n    [0.588370978832245, 0.804440975189209],\n    [0.52079701423645, 0.442565023899078],\n    [0.567984998226166, 0.493479013442993],\n    [0.543282985687256, 0.819254994392395],\n    [0.655317008495331, 0.745514988899231],\n    [0.621008992195129, 0.574018001556396],\n    [0.625559985637665, 0.78031200170517],\n    [0.680198013782501, 0.570719003677368],\n    [0.64276397228241, 0.604337990283966],\n    [0.704662978649139, 0.621529996395111],\n    [0.552012026309967, 0.862591981887817],\n    [0.589071989059448, 0.508637011051178],\n    [0.685944974422455, 0.775357007980347],\n    [0.645735025405884, 0.812640011310577],\n    [0.675342977046967, 0.703978002071381],\n    [0.810858011245728, 0.646304965019226],\n    [0.72012197971344, 0.714666962623596],\n    [0.866151988506317, 0.682704985141754],\n    [0.663187026977539, 0.644596993923187],\n    [0.570082008838654, 0.466325998306274],\n    [0.544561982154846, 0.548375964164734],\n    [0.562758982181549, 0.558784961700439],\n    [0.531987011432648, 0.530140042304993],\n    [0.585271000862122, 0.335177004337311],\n    [0.622952997684479, 0.32277899980545],\n    [0.655896008014679, 0.320163011550903],\n    [0.687132000923157, 0.322345972061157],\n    [0.716481983661652, 0.333200991153717],\n    [0.758756995201111, 0.382786989212036],\n    [0.897013008594513, 0.468769013881683],\n    [0.732392013072968, 0.424547016620636],\n    [0.70211398601532, 0.433162987232208],\n    [0.66652500629425, 0.433866024017334],\n    [0.633504986763, 0.426087975502014],\n    [0.603875994682312, 0.416586995124817],\n    [0.579657971858978, 0.409945011138916],\n    [0.992439985275269, 0.480777025222778],\n    [0.567192018032074, 0.569419980049133],\n    [0.54136598110199, 0.478899002075195],\n    [0.526564002037048, 0.546118021011353],\n    [0.523913025856018, 0.563830018043518],\n    [0.531529009342194, 0.555056989192963],\n    [0.566035985946655, 0.582329034805298],\n    [0.51631098985672, 0.563053965568542],\n    [0.5174720287323, 0.577877044677734],\n    [0.573594987392426, 0.389806985855103],\n    [0.560697972774506, 0.395331978797913],\n    [0.549755990505219, 0.399751007556915],\n    [0.710287988185883, 0.368252992630005],\n    [0.723330020904541, 0.363372981548309]\n];\n//# sourceMappingURL=uv_coords.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3ctbW9kZWxzL2ZhY2UtbGFuZG1hcmtzLWRldGVjdGlvbi9kaXN0L21lZGlhcGlwZS1mYWNlbWVzaC91dl9jb29yZHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWVjb21tZXJjZS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93LW1vZGVscy9mYWNlLWxhbmRtYXJrcy1kZXRlY3Rpb24vZGlzdC9tZWRpYXBpcGUtZmFjZW1lc2gvdXZfY29vcmRzLmpzPzYwNjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VVl9DT09SRFMgPSBbXG4gICAgWzAuNDk5OTc2OTkyNjA3MTE3LCAwLjY1MjUzNDAwODAyNjEyM10sXG4gICAgWzAuNTAwMDI1OTg3NjI1MTIyLCAwLjU0NzQ4NzAyMDQ5MjU1NF0sXG4gICAgWzAuNDk5OTc0MDEyMzc0ODc4LCAwLjYwMjM3MTk5MDY4MDY5NV0sXG4gICAgWzAuNDgyMTEzMDAzNzMwNzc0LCAwLjQ3MTk3OTAyMjAyNjA2Ml0sXG4gICAgWzAuNTAwMTUwOTc4NTY1MjE2LCAwLjUyNzE1NTk5NTM2ODk1OF0sXG4gICAgWzAuNDk5OTA5OTk2OTg2Mzg5LCAwLjQ5ODI1Mjk4Nzg2MTYzM10sXG4gICAgWzAuNDk5NTIzMDEzODMwMTg1LCAwLjQwMTA2MjAxMTcxODc1XSxcbiAgICBbMC4yODk3MTIwMTE4MTQxMTcsIDAuMzgwNzY0MDA3NTY4MzU5XSxcbiAgICBbMC40OTk5NTQ5OTg0OTMxOTUsIDAuMzEyMzk4MDE2NDUyNzg5XSxcbiAgICBbMC40OTk5ODcwMDYxODc0MzksIDAuMjY5OTE4OTc4MjE0MjY0XSxcbiAgICBbMC41MDAwMjMwMDczOTI4ODMsIDAuMTA3MDUwMDAxNjIxMjQ2XSxcbiAgICBbMC41MDAwMjMwMDczOTI4ODMsIDAuNjY2MjM0MDE2NDE4NDU3XSxcbiAgICBbMC41MDAwMTU5NzQwNDQ4LCAwLjY3OTIyNDAxNDI4MjIyN10sXG4gICAgWzAuNTAwMDIzMDA3MzkyODgzLCAwLjY5MjM0ODAwMzM4NzQ1MV0sXG4gICAgWzAuNDk5OTc2OTkyNjA3MTE3LCAwLjY5NTI3Nzk4ODkxMDY3NV0sXG4gICAgWzAuNDk5OTc2OTkyNjA3MTE3LCAwLjcwNTkzMzk4ODA5NDMzXSxcbiAgICBbMC40OTk5NzY5OTI2MDcxMTcsIDAuNzE5Mzg1MDI3ODg1NDM3XSxcbiAgICBbMC40OTk5NzY5OTI2MDcxMTcsIDAuNzM3MDE5MDAyNDM3NTkyXSxcbiAgICBbMC40OTk5Njc5OTIzMDU3NTYsIDAuNzgxMzcwOTk3NDI4ODk0XSxcbiAgICBbMC40OTk4MTYwMDA0NjE1NzgsIDAuNTYyOTgxMDA5NDgzMzM3XSxcbiAgICBbMC40NzM3NzMwMDI2MjQ1MTIsIDAuNTczOTA5OTk3OTQwMDYzXSxcbiAgICBbMC4xMDQ5MDY5OTg1NzQ3MzQsIDAuMjU0MTQwOTczMDkxMTI1XSxcbiAgICBbMC4zNjU5Mjk5OTEwMDY4NTEsIDAuNDA5NTc1OTk4NzgzMTEyXSxcbiAgICBbMC4zMzg3NTc5OTE3OTA3NzEsIDAuNDEzMDI1MDIxNTUzMDRdLFxuICAgIFswLjMxMTEyMDAwMzQ2MTgzOCwgMC40MDk0NjAwMDgxNDQzNzldLFxuICAgIFswLjI3NDY1Nzk5NDUwODc0MywgMC4zODkxMzEwMDk1Nzg3MDVdLFxuICAgIFswLjM5MzM2MTk4NTY4MzQ0MSwgMC40MDM3MDYwMTQxNTYzNDJdLFxuICAgIFswLjM0NTIzNDAwNjY0MzI5NSwgMC4zNDQwMTEwMDg3Mzk0NzFdLFxuICAgIFswLjM3MDA5NDAwMTI5MzE4MiwgMC4zNDYwNzYwMTE2NTc3MTVdLFxuICAgIFswLjMxOTMyMTk5MDAxMzEyMywgMC4zNDcyNjUwMDUxMTE2OTRdLFxuICAgIFswLjI5NzkwMzAwMTMwODQ0MSwgMC4zNTM1OTEwMjQ4NzU2NDFdLFxuICAgIFswLjI0Nzc5MjAwNTUzODk0LCAwLjQxMDgwOTk5Mzc0Mzg5Nl0sXG4gICAgWzAuMzk2ODg5MDAxMTMxMDU4LCAwLjg0Mjc1NTAxOTY2NDc2NF0sXG4gICAgWzAuMjgwMDk3OTkxMjI4MTA0LCAwLjM3NTU5OTk4MDM1NDMwOV0sXG4gICAgWzAuMTA2MzEwMDAyNTA1Nzc5LCAwLjM5OTk1NTk4NzkzMDI5OF0sXG4gICAgWzAuMjA5OTI0OTk1ODk5MiwgMC4zOTEzNTMwMTExMzEyODddLFxuICAgIFswLjM1NTgwNzk4OTgzNTczOSwgMC41MzQ0MDYwMDYzMzYyMTJdLFxuICAgIFswLjQ3MTc1MTAwNDQ1NzQ3NCwgMC42NTA0MDM5NzY0NDA0M10sXG4gICAgWzAuNDc0MTU1MDA4NzkyODc3LCAwLjY4MDE5MTk5MzcxMzM3OV0sXG4gICAgWzAuNDM5Nzg1MDAzNjYyMTA5LCAwLjY1NzIyOTAwNjI5MDQzNl0sXG4gICAgWzAuNDE0NjE3MDAyMDEwMzQ1LCAwLjY2NjU0MDk4MDMzOTA1XSxcbiAgICBbMC40NTAzNzQwMDcyMjUwMzcsIDAuNjgwODYwOTk2MjQ2MzM4XSxcbiAgICBbMC40Mjg3NzA5ODkxNzk2MTEsIDAuNjgyNjkwOTc4MDUwMjMyXSxcbiAgICBbMC4zNzQ5NzEwMDIzNDAzMTcsIDAuNzI3ODA1MDE4NDI0OTg4XSxcbiAgICBbMC40ODY3MTY5ODU3MDI1MTUsIDAuNTQ3NjI4OTk4NzU2NDA5XSxcbiAgICBbMC40ODUzMDA5ODc5NTg5MDgsIDAuNTI3Mzk1MDA5OTk0NTA3XSxcbiAgICBbMC4yNTc3NjQ5OTUwOTgxMTQsIDAuMzE0NDkwMDIwMjc1MTE2XSxcbiAgICBbMC40MDEyMjMwMDM4NjQyODgsIDAuNDU1MTcyMDAyMzE1NTIxXSxcbiAgICBbMC40Mjk4MTg5ODc4NDYzNzUsIDAuNTQ4NjE0OTc4NzkwMjgzXSxcbiAgICBbMC40MjEzNTE5OTkwNDQ0MTgsIDAuNTMzNzQwOTk3MzE0NDUzXSxcbiAgICBbMC4yNzY4OTU5OTk5MDg0NDcsIDAuNTMyMDU2OTg3Mjg1NjE0XSxcbiAgICBbMC40ODMzNzAwMDYwODQ0NDIsIDAuNDk5NTg2OTk5NDE2MzUxXSxcbiAgICBbMC4zMzcyMTE5OTYzMTY5MSwgMC4yODI4ODI5ODg0NTI5MTFdLFxuICAgIFswLjI5NjM5MTk5Mzc2MTA2MywgMC4yOTMyNDI5OTA5NzA2MTJdLFxuICAgIFswLjE2OTI5NDk5ODA0OTczNiwgMC4xOTM4MTM5Nzk2MjU3MDJdLFxuICAgIFswLjQ0NzU4MDAwOTY5ODg2OCwgMC4zMDI2MDk5ODAxMDYzNTRdLFxuICAgIFswLjM5MjM5MDAxMjc0MTA4OSwgMC4zNTM4ODc5NzUyMTU5MTJdLFxuICAgIFswLjM1NDQ5MDAxMTkzMDQ2NiwgMC42OTY3ODQwMTk0NzAyMTVdLFxuICAgIFswLjA2NzMwNDk5ODYzNjI0NiwgMC43MzAxMDUwNDI0NTc1ODFdLFxuICAgIFswLjQ0MjczOTAwOTg1NzE3OCwgMC41NzI4MjYwMjc4NzAxNzhdLFxuICAgIFswLjQ1NzA5ODAwNzIwMjE0OCwgMC41ODQ3OTIwMTc5MzY3MDddLFxuICAgIFswLjM4MTk3NDAxMTY1OTYyMiwgMC42OTQ3MTA5Njk5MjQ5MjddLFxuICAgIFswLjM5MjM4ODk5OTQ2MjEyOCwgMC42OTQyMDMwMTkxNDIxNTFdLFxuICAgIFswLjI3NzA3NjAwNTkzNTY2OSwgMC4yNzE5MzIwMDU4ODIyNjNdLFxuICAgIFswLjQyMjU1MTk4OTU1NTM1OSwgMC41NjMyMzMwMTc5MjE0NDhdLFxuICAgIFswLjM4NTkxOTAwNDY3ODcyNiwgMC4yODEzNjQwMjM2ODU0NTVdLFxuICAgIFswLjM4MzEwMzAxMzAzODYzNSwgMC4yNTU4NDAwMDM0OTA0NDhdLFxuICAgIFswLjMzMTQzMTAwMTQyNDc4OSwgMC4xMTk3MTQwMjE2ODI3MzldLFxuICAgIFswLjIyOTkyMzk5MzM0OTA3NSwgMC4yMzIwMDI5NzM1NTY1MTldLFxuICAgIFswLjM2NDUwMDk5OTQ1MDY4NCwgMC4xODkxMTM5NzQ1NzEyMjhdLFxuICAgIFswLjIyOTYyMjAwNjQxNjMyMSwgMC4yOTk1NDA5OTY1NTE1MTRdLFxuICAgIFswLjE3MzI4NzAwNDIzMjQwNywgMC4yNzg3NDc5NzU4MjYyNjNdLFxuICAgIFswLjQ3Mjg3ODk5MjU1NzUyNiwgMC42NjYxOTgwMTUyMTMwMTNdLFxuICAgIFswLjQ0NjgyODAwNzY5ODA1OSwgMC42Njg1MjcwMDcxMDI5NjZdLFxuICAgIFswLjQyMjc2MjAwNjUyMTIyNSwgMC42NzM4ODk5OTQ2MjEyNzddLFxuICAgIFswLjQ0NTMwNzk5OTg0OTMxOSwgMC41ODAwNjU5NjU2NTI0NjZdLFxuICAgIFswLjM4ODEwMzAwODI3MDI2NCwgMC42OTM5NjEwMjQyODQzNjNdLFxuICAgIFswLjQwMzAzOTAwODM3ODk4MywgMC43MDY1Mzk5ODg1MTc3NjFdLFxuICAgIFswLjQwMzYyOTAwNDk1NTI5MiwgMC42OTM5NTMwMzcyNjE5NjNdLFxuICAgIFswLjQ2MDA0MTk5OTgxNjg5NSwgMC41NTcxMzkwMzkwMzk2MTJdLFxuICAgIFswLjQzMTE1ODAwNjE5MTI1NCwgMC42OTIzNjYwMDM5OTAxNzNdLFxuICAgIFswLjQ1MjE4MTk5NDkxNTAwOSwgMC42OTIzNjYwMDM5OTAxNzNdLFxuICAgIFswLjQ3NTM4NzAwNjk5ODA2MiwgMC42OTIzNjYwMDM5OTAxNzNdLFxuICAgIFswLjQ2NTgyODAwMTQ5OTE3NiwgMC43NzkxOTAwMDM4NzE5MThdLFxuICAgIFswLjQ3MjMyODk5MDY5Nzg2MSwgMC43MzYyMjU5NjI2Mzg4NTVdLFxuICAgIFswLjQ3MzA4NzAxMjc2Nzc5MiwgMC43MTc4NTcwMDMyMTE5NzVdLFxuICAgIFswLjQ3MzEyMjAwMDY5NDI3NSwgMC43MDQ2MjU5NjQxNjQ3MzRdLFxuICAgIFswLjQ3MzAzMzAxMDk1OTYyNSwgMC42OTUyNzc5ODg5MTA2NzVdLFxuICAgIFswLjQyNzk0MjAwNzc4MDA3NSwgMC42OTUyNzc5ODg5MTA2NzVdLFxuICAgIFswLjQyNjQ3OTAxMTc3NDA2MywgMC43MDM1Mzk5Njc1MzY5MjZdLFxuICAgIFswLjQyMzE2MjAxMzI5MjMxMywgMC43MTE4NDU5OTM5OTU2NjddLFxuICAgIFswLjQxODMwOTAwMzExNDcsIDAuNzIwMDYyOTcxMTE1MTEyXSxcbiAgICBbMC4zOTAwOTQ5OTU0OTg2NTcsIDAuNjM5NTcyOTc4MDE5NzE0XSxcbiAgICBbMC4wMTM5NTM5OTk2MTYyMDYsIDAuNTYwMDM0MDM2NjM2MzUzXSxcbiAgICBbMC40OTk5MTM5OTA0OTc1ODksIDAuNTgwMTQ3MDI3OTY5MzZdLFxuICAgIFswLjQxMzE5OTk5MDk4Nzc3OCwgMC42OTUzOTk5OTk2MTg1M10sXG4gICAgWzAuNDA5NjI2MDA3MDgwMDc4LCAwLjcwMTgyMjk5NjEzOTUyNl0sXG4gICAgWzAuNDY4MDgwMDEzOTkwNDAyLCAwLjYwMTUzNDk2MjY1NDExNF0sXG4gICAgWzAuNDIyNzI4OTg1NTQ4MDE5LCAwLjU4NTk4NTAwNDkwMTg4Nl0sXG4gICAgWzAuNDYzMDc5OTg4OTU2NDUxLCAwLjU5Mzc4Mzk3NDY0NzUyMl0sXG4gICAgWzAuMzcyMTE5OTkyOTcxNDIsIDAuNDczNDE0MDAzODQ5MDNdLFxuICAgIFswLjMzNDU2MjAwMzYxMjUxOCwgMC40OTYwNzMwMDc1ODM2MThdLFxuICAgIFswLjQxMTY3MTAxMjYzOTk5OSwgMC41NDY5NjUwMDMwMTM2MTFdLFxuICAgIFswLjI0MjE3NTk5NjMwMzU1OCwgMC4xNDc2NzU5OTEwNTgzNV0sXG4gICAgWzAuMjkwNzc2OTk3ODA0NjQyLCAwLjIwMTQ0NTk5Njc2MTMyMl0sXG4gICAgWzAuMzI3MzM4MDEwMDcyNzA4LCAwLjI1NjUyNzAwNjYyNjEyOV0sXG4gICAgWzAuMzk5NTA5OTk2MTc1NzY2LCAwLjc0ODkyMTAzNjcyMDI3Nl0sXG4gICAgWzAuNDQxNzI3OTk1ODcyNDk4LCAwLjI2MTY3NjAxMzQ2OTY5Nl0sXG4gICAgWzAuNDI5NzY0OTg2MDM4MjA4LCAwLjE4NzgzNDAyNDQyOTMyMV0sXG4gICAgWzAuNDEyMTk4MDA3MTA2NzgxLCAwLjEwODkwMTAyMzg2NDc0Nl0sXG4gICAgWzAuMjg4OTU1MDAzMDIzMTQ4LCAwLjM5ODk1MjAwNzI5MzcwMV0sXG4gICAgWzAuMjE4OTM2OTk0NjcxODIyLCAwLjQzNTQxMDk3NjQwOTkxMl0sXG4gICAgWzAuNDEyNzgyMDEzNDE2MjksIDAuMzk4OTcwMDA3ODk2NDIzXSxcbiAgICBbMC4yNTcxMzUwMDM4MDUxNjEsIDAuMzU1NDQwMDIwNTYxMjE4XSxcbiAgICBbMC40Mjc2ODQ5OTI1NTE4MDQsIDAuNDM3OTYwOTgyMzIyNjkzXSxcbiAgICBbMC40NDgzMzk5OTg3MjIwNzYsIDAuNTM2OTM2MDQ0NjkyOTkzXSxcbiAgICBbMC4xNzg1NjAwMDM2MzgyNjgsIDAuNDU3NTUzOTgyNzM0NjhdLFxuICAgIFswLjI0NzMwODAwMDkyMjIwMywgMC40NTcxOTM5NzA2ODAyMzddLFxuICAgIFswLjI4NjI2NzAxMjM1NzcxMiwgMC40Njc2NzQ5NzA2MjY4MzFdLFxuICAgIFswLjMzMjgyNzk4NTI4NjcxMywgMC40NjA3MTIwMTU2Mjg4MTVdLFxuICAgIFswLjM2ODc1NTk5NjIyNzI2NCwgMC40NDcyMDY5NzQwMjk1NDFdLFxuICAgIFswLjM5ODk2Mzk4NzgyNzMwMSwgMC40MzI2NTQ5NzY4NDQ3ODhdLFxuICAgIFswLjQ3NjQxMDAwMTUxNjM0MiwgMC40MDU4MDYwMDUwMDEwNjhdLFxuICAgIFswLjE4OTI0MTAwNjk3MDQwNiwgMC41MjM5MjM5OTMxMTA2NTddLFxuICAgIFswLjIyODk2MjAwNDE4NDcyMywgMC4zNDg5NTA5ODIwOTM4MTFdLFxuICAgIFswLjQ5MDcyNTk5NDExMDEwNywgMC41NjI0MDA5OTY2ODUwMjhdLFxuICAgIFswLjQwNDY3MDAwMDA3NjI5NCwgMC40ODUxMzI5OTIyNjc2MDldLFxuICAgIFswLjAxOTQ2OTAwMDM5OTExMywgMC40MDE1NjQwMDIwMzcwNDhdLFxuICAgIFswLjQyNjI0MzAwNzE4MzA3NSwgMC40MjA0MzEwMTc4NzU2NzFdLFxuICAgIFswLjM5Njk5MzAxMTIzNjE5MSwgMC41NDg3OTcwMTEzNzU0MjddLFxuICAgIFswLjI2NjQ2OTk4NTI0NjY1OCwgMC4zNzY5NzcwMjY0NjI1NTVdLFxuICAgIFswLjQzOTEyMTAwNzkxOTMxMiwgMC41MTg5NTc5NzI1MjY1NV0sXG4gICAgWzAuMDMyMzEzOTk4Nzg4NTk1LCAwLjY0NDM1Njk2NjAxODY3N10sXG4gICAgWzAuNDE5MDU0MDAxNTY5NzQ4LCAwLjM4NzE1NDk5NjM5NTExMV0sXG4gICAgWzAuNDYyNzgzMDA4ODEzODU4LCAwLjUwNTc0Njk2MDYzOTk1NF0sXG4gICAgWzAuMjM4OTc4OTk2ODcyOTAyLCAwLjc3OTc0NDk4MjcxOTQyMV0sXG4gICAgWzAuMTk4MjIwOTk4MDQ4NzgyLCAwLjgzMTkzODAyODMzNTU3MV0sXG4gICAgWzAuMTA3NTUwMDAyNjM0NTI1LCAwLjU0MDc1NTAzMzQ5MzA0Ml0sXG4gICAgWzAuMTgzNjEwMDA3MTY2ODYyLCAwLjc0MDI1NzAyNDc2NTAxNV0sXG4gICAgWzAuMTM0NDA5OTkzODg2OTQ4LCAwLjMzMzY4MzAxMzkxNjAxNl0sXG4gICAgWzAuMzg1NzY0MDAyNzk5OTg4LCAwLjg4MzE1Mzk3NTAwOTkxOF0sXG4gICAgWzAuNDkwOTY3MDA1NDkxMjU3LCAwLjU3OTM3ODAwODg0MjQ2OF0sXG4gICAgWzAuMzgyMzg0OTg1Njg1MzQ5LCAwLjUwODU3Mjk5NTY2MjY4OV0sXG4gICAgWzAuMTc0Mzk5MDAzMzg2NDk3LCAwLjM5NzY3MDk4NDI2ODE4OF0sXG4gICAgWzAuMzE4Nzg1MDExNzY4MzQxLCAwLjM5NjIzNDk4OTE2NjI2XSxcbiAgICBbMC4zNDMzNjQwMDAzMjA0MzUsIDAuNDAwNTk2OTc2MjgwMjEyXSxcbiAgICBbMC4zOTYxMDAwMTQ0NDgxNjYsIDAuNzEwMjE2OTk5MDUzOTU1XSxcbiAgICBbMC4xODc4ODUwMDEzMDE3NjUsIDAuNTg4NTM3OTkxMDQ2OTA2XSxcbiAgICBbMC40MzA5ODcwMDA0NjUzOTMsIDAuOTQ0MDY0OTc0Nzg0ODUxXSxcbiAgICBbMC4zMTg5OTMwMDIxNzYyODUsIDAuODk4Mjg1MDMxMzE4NjY1XSxcbiAgICBbMC4yNjYyNDc5ODc3NDcxOTIsIDAuODY5NzAxMDI3ODcwMTc4XSxcbiAgICBbMC41MDAwMjMwMDczOTI4ODMsIDAuMTkwNTc2MDE2OTAyOTI0XSxcbiAgICBbMC40OTk5NzY5OTI2MDcxMTcsIDAuOTU0NDUyOTkxNDg1NTk2XSxcbiAgICBbMC4zNjYxNjk5ODkxMDkwMzksIDAuMzk4ODIyMDA5NTYzNDQ2XSxcbiAgICBbMC4zOTMyMDcwMTM2MDcwMjUsIDAuMzk1NTM3MDE4Nzc1OTRdLFxuICAgIFswLjQxMDM3MzAwMjI5MDcyNiwgMC4zOTEwODAwMjE4NTgyMTVdLFxuICAgIFswLjE5NDk5MzAwNDIwMjg0MywgMC4zNDIxMDE5OTExNzY2MDVdLFxuICAgIFswLjM4ODY2NDk5MDY2MzUyOCwgMC4zNjIyODQwMDQ2ODgyNjNdLFxuICAgIFswLjM2NTk2MTk5ODcwMTA5NiwgMC4zNTU5NzA5Nzg3MzY4NzddLFxuICAgIFswLjM0MzM2NDAwMDMyMDQzNSwgMC4zNTUzNTY5OTEyOTEwNDZdLFxuICAgIFswLjMxODc4NTAxMTc2ODM0MSwgMC4zNTgzNDAwMjQ5NDgxMl0sXG4gICAgWzAuMzAxNDE0OTk2Mzg1NTc0LCAwLjM2MzE1NjAyMDY0MTMyN10sXG4gICAgWzAuMDU4MTMyOTk4NjQ1MzA2LCAwLjMxOTA3NjAwMTY0NDEzNV0sXG4gICAgWzAuMzAxNDE0OTk2Mzg1NTc0LCAwLjM4NzQ0OTAyNjEwNzc4OF0sXG4gICAgWzAuNDk5OTg3OTg5NjY0MDc4LCAwLjYxODQzNDAxMTkzNjE4OF0sXG4gICAgWzAuNDE1ODM4MDAzMTU4NTY5LCAwLjYyNDE5NTk5Mjk0NjYyNV0sXG4gICAgWzAuNDQ1NjgxOTg5MTkyOTYzLCAwLjU2NjA3Njk5Mzk0MjI2MV0sXG4gICAgWzAuNDY1ODQ0MDA1MzQ2Mjk4LCAwLjYyMDY0MDk5MzExODI4Nl0sXG4gICAgWzAuNDk5OTIyOTkwNzk4OTUsIDAuMzUxNTIzOTk1Mzk5NDc1XSxcbiAgICBbMC4yODg3MTg5OTg0MzIxNTksIDAuODE5OTQ1OTkxMDM5Mjc2XSxcbiAgICBbMC4zMzUyNzg5ODc4ODQ1MjEsIDAuODUyODE5OTc5MTkwODI2XSxcbiAgICBbMC40NDA1MTIwMDE1MTQ0MzUsIDAuOTAyNDE4OTcxMDYxNzA3XSxcbiAgICBbMC4xMjgyOTQwMDU5OTAwMjgsIDAuNzkxOTQwOTg3MTEwMTM4XSxcbiAgICBbMC40MDg3NzE5OTE3Mjk3MzYsIDAuMzczODkzOTc2MjExNTQ4XSxcbiAgICBbMC40NTU2MDY5OTcwMTMwOTIsIDAuNDUxODAxMDAyMDI1NjA0XSxcbiAgICBbMC40OTk4NzcwMDU4MTU1MDYsIDAuOTA4OTkwMDI1NTIwMzI1XSxcbiAgICBbMC4zNzU0MzY5OTE0NTMxNzEsIDAuOTI0MTkyMDExMzU2MzU0XSxcbiAgICBbMC4xMTQyMTAwMDIxMjQzMSwgMC42MTUwMjIwMDM2NTA2NjVdLFxuICAgIFswLjQ0ODY2MjAxMjgxNTQ3NSwgMC42OTUyNzc5ODg5MTA2NzVdLFxuICAgIFswLjQ0ODAyMDAxMTE4NjYsIDAuNzA0NjMyMDQzODM4NTAxXSxcbiAgICBbMC40NDcxMTE5OTQwMjgwOTEsIDAuNzE1ODA4MDMzOTQzMTc2XSxcbiAgICBbMC40NDQ4MzE5OTcxNTYxNDMsIDAuNzMwNzk0MDEyNTQ2NTM5XSxcbiAgICBbMC40MzAwMTE5ODc2ODYxNTcsIDAuNzY2ODA4OTg2NjYzODE4XSxcbiAgICBbMC40MDY3ODcwMDgwNDcxMDQsIDAuNjg1NjcyOTk4NDI4MzQ1XSxcbiAgICBbMC40MDA3MzgwMDA4Njk3NTEsIDAuNjgxMDY5MDE2NDU2NjA0XSxcbiAgICBbMC4zOTIzOTk5OTY1MTkwODksIDAuNjc3NzAzMDIyOTU2ODQ4XSxcbiAgICBbMC4zNjc4NTU5OTU4OTM0NzgsIDAuNjYzOTE4OTcyMDE1MzgxXSxcbiAgICBbMC4yNDc5MjMwMDE2NDY5OTYsIDAuNjAxMzMzMDIyMTE3NjE1XSxcbiAgICBbMC40NTI3Njk5OTQ3MzU3MTgsIDAuNDIwODQ5OTc4OTIzNzk4XSxcbiAgICBbMC40MzYzOTIwMDkyNTgyNywgMC4zNTk4ODcwMDM4OTg2MjFdLFxuICAgIFswLjQxNjE2NDAxMDc2MzE2OCwgMC4zNjg3MTM5NzQ5NTI2OThdLFxuICAgIFswLjQxMzM4NTk4NzI4MTc5OSwgMC42OTIzNjYwMDM5OTAxNzNdLFxuICAgIFswLjIyODAxODAwMDcyMTkzMSwgMC42ODM1NzE5OTQzMDQ2NTddLFxuICAgIFswLjQ2ODI2ODAwNzA0MDAyNCwgMC4zNTI2NzEwMjcxODM1MzNdLFxuICAgIFswLjQxMTM2MTk5MjM1OTE2MSwgMC44MDQzMjcwMTExMDgzOThdLFxuICAgIFswLjQ5OTk4OTAwMjk0MzAzOSwgMC40Njk4MjUwMjkzNzMxNjldLFxuICAgIFswLjQ3OTE1Mzk5MDc0NTU0NCwgMC40NDI2NTQwMTM2MzM3MjhdLFxuICAgIFswLjQ5OTk3NDAxMjM3NDg3OCwgMC40Mzk2MzcwMDUzMjkxMzJdLFxuICAgIFswLjQzMjExMjAwODMzMzIwNiwgMC40OTM1ODg5ODQwMTI2MDRdLFxuICAgIFswLjQ5OTg4NjAwNjExNjg2NywgMC44NjY5MTcwMTQxMjIwMDldLFxuICAgIFswLjQ5OTkxMzAwNzAyMDk1LCAwLjgyMTcyOTAwNDM4MzA4N10sXG4gICAgWzAuNDU2NTQ4OTg4ODE5MTIyLCAwLjgxOTIwMDk5MjU4NDIyOV0sXG4gICAgWzAuMzQ0NTQ5MDAwMjYzMjE0LCAwLjc0NTQzODk5Mjk3NzE0Ml0sXG4gICAgWzAuMzc4OTA4OTkxODEzNjYsIDAuNTc0MDEwMDE0NTMzOTk3XSxcbiAgICBbMC4zNzQyOTI5OTk1MDU5OTcsIDAuNzgwMTg0OTg0MjA3MTUzXSxcbiAgICBbMC4zMTk2ODc5OTIzMzQzNjYsIDAuNTcwNzM3OTU3OTU0NDA3XSxcbiAgICBbMC4zNTcxNTQ5OTUyMDMwMTgsIDAuNjA0MjY5OTgxMzg0Mjc3XSxcbiAgICBbMC4yOTUyODQwMDMwMTkzMzMsIDAuNjIxNTgwOTU4MzY2Mzk0XSxcbiAgICBbMC40NDc3NTAwMDIxNDU3NjcsIDAuODYyNDc3MDA0NTI4MDQ2XSxcbiAgICBbMC40MTA5ODYwMDYyNTk5MTgsIDAuNTA4NzIzMDIwNTUzNTg5XSxcbiAgICBbMC4zMTM5NTA5ODU2NzAwOSwgMC43NzUzMDgwMTI5NjIzNDFdLFxuICAgIFswLjM1NDEyODAwMzEyMDQyMiwgMC44MTI1NTI5ODg1MjkyMDVdLFxuICAgIFswLjMyNDU0ODAwNjA1NzczOSwgMC43MDM5OTI5NjI4MzcyMTldLFxuICAgIFswLjE4OTA5NjAwMzc3MDgyOCwgMC42NDYyOTk5NTgyMjkwNjVdLFxuICAgIFswLjI3OTc3Njk5MDQxMzY2NiwgMC43MTQ2NTgwMjE5MjY4OF0sXG4gICAgWzAuMTMzODIzMDA3MzQ1MiwgMC42ODI3MDA5OTE2MzA1NTRdLFxuICAgIFswLjMzNjc2ODAwMTMxNzk3OCwgMC42NDQ3MzMwMTE3MjI1NjVdLFxuICAgIFswLjQyOTg4Mzk4NjcxMTUwMiwgMC40NjY1MjE5NzgzNzgyOTZdLFxuICAgIFswLjQ1NTUyNzk5MTA1NjQ0MiwgMC41NDg2MjI5NjU4MTI2ODNdLFxuICAgIFswLjQzNzExNDAwMDMyMDQzNSwgMC41NTg4OTYwMDUxNTM2NTZdLFxuICAgIFswLjQ2NzI4Nzk4NzQ3MDYyNywgMC41Mjk5MjQ5ODg3NDY2NDNdLFxuICAgIFswLjQxNDcxMjAxMTgxNDExNywgMC4zMzUyMTk5NzkyODYxOTRdLFxuICAgIFswLjM3NzA0NTk4OTAzNjU2LCAwLjMyMjc3Nzk4NjUyNjQ4OV0sXG4gICAgWzAuMzQ0MTA3OTg1NDk2NTIxLCAwLjMyMDE1MDk3MTQxMjY1OV0sXG4gICAgWzAuMzEyODc1OTg2MDk5MjQzLCAwLjMyMjMzMjAyNDU3NDI4XSxcbiAgICBbMC4yODM1MjYwMDMzNjA3NDgsIDAuMzMzMTkwMDIzODk5MDc4XSxcbiAgICBbMC4yNDEyNDU5OTk5MzIyODksIDAuMzgyNzg1OTc1OTMzMDc1XSxcbiAgICBbMC4xMDI5ODYwMDA0NzgyNjgsIDAuNDY4NzYyOTkzODEyNTYxXSxcbiAgICBbMC4yNjc2MTIwMTAyNDA1NTUsIDAuNDI0NTYwMDEwNDMzMTk3XSxcbiAgICBbMC4yOTc4NzkwMTA0Mzg5MTksIDAuNDMzMTc1OTgxMDQ0NzY5XSxcbiAgICBbMC4zMzM0MzM5ODU3MTAxNDQsIDAuNDMzODc4MDA0NTUwOTM0XSxcbiAgICBbMC4zNjY0MjcwMDQzMzczMTEsIDAuNDI2MTE1OTg5Njg1MDU5XSxcbiAgICBbMC4zOTYwMTIwMDgxOTAxNTUsIDAuNDE2Njk2MDEyMDIwMTExXSxcbiAgICBbMC40MjAxMjEwMTQxMTgxOTUsIDAuNDEwMjI4MDEzOTkyMzFdLFxuICAgIFswLjAwNzU2MTAwMDA2NDAxNSwgMC40ODA3NzcwMjUyMjI3NzhdLFxuICAgIFswLjQzMjk0OTAwNjU1NzQ2NSwgMC41Njk1MTc5NzAwODUxNDRdLFxuICAgIFswLjQ1ODYzODk5NTg4NTg0OSwgMC40NzkwODkwMjE2ODI3MzldLFxuICAgIFswLjQ3MzQ2NjAwODkwMTU5NiwgMC41NDU3NDQwMDE4NjUzODddLFxuICAgIFswLjQ3NjA4Nzk4NzQyMjk0MywgMC41NjM4MzAwMTgwNDM1MThdLFxuICAgIFswLjQ2ODQ3MjAwMzkzNjc2OCwgMC41NTUwNTY5ODkxOTI5NjNdLFxuICAgIFswLjQzMzk5MDk4NTE1NTEwNiwgMC41ODIzNjE5OTYxNzM4NTldLFxuICAgIFswLjQ4MzUxODAwNDQxNzQxOSwgMC41NjI5ODM5ODk3MTU1NzZdLFxuICAgIFswLjQ4MjQ4Mjk5OTU2MzIxNywgMC41Nzc4NDkwMzA0OTQ2OV0sXG4gICAgWzAuNDI2NDUwMDE0MTE0MzgsIDAuMzg5Nzk4OTk4ODMyNzAzXSxcbiAgICBbMC40Mzg5OTg5OTcyMTE0NTYsIDAuMzk2NDk0OTg0NjI2NzddLFxuICAgIFswLjQ1MDA2NzAxMzUwMjEyMSwgMC40MDA0MzQwMTcxODEzOTZdLFxuICAgIFswLjI4OTcxMjAxMTgxNDExNywgMC4zNjgyNTI5OTI2MzAwMDVdLFxuICAgIFswLjI3NjY3MDAwODg5Nzc4MSwgMC4zNjMzNzI5ODE1NDgzMDldLFxuICAgIFswLjUxNzg2MjAyMTkyMzA2NSwgMC40NzE5NDgwMjc2MTA3NzldLFxuICAgIFswLjcxMDI4Nzk4ODE4NTg4MywgMC4zODA3NjQwMDc1NjgzNTldLFxuICAgIFswLjUyNjIyNjk5NzM3NTQ4OCwgMC41NzM5MDk5OTc5NDAwNjNdLFxuICAgIFswLjg5NTA5MzAyMzc3NzAwOCwgMC4yNTQxNDA5NzMwOTExMjVdLFxuICAgIFswLjYzNDA2OTk3OTE5MDgyNiwgMC40MDk1NzU5OTg3ODMxMTJdLFxuICAgIFswLjY2MTI0MjAwODIwOTIyOSwgMC40MTMwMjUwMjE1NTMwNF0sXG4gICAgWzAuNjg4ODgwMDI2MzQwNDg1LCAwLjQwOTQ2MDAwODE0NDM3OV0sXG4gICAgWzAuNzI1MzQxOTc1Njg4OTM0LCAwLjM4OTEzMTAwOTU3ODcwNV0sXG4gICAgWzAuNjA2NjMwMDI3Mjk0MTU5LCAwLjQwMzcwNTAwMDg3NzM4XSxcbiAgICBbMC42NTQ3NjYwMjMxNTkwMjcsIDAuMzQ0MDExMDA4NzM5NDcxXSxcbiAgICBbMC42Mjk5MDU5OTg3MDY4MTgsIDAuMzQ2MDc2MDExNjU3NzE1XSxcbiAgICBbMC42ODA2NzgwMDk5ODY4NzcsIDAuMzQ3MjY1MDA1MTExNjk0XSxcbiAgICBbMC43MDIwOTY5OTg2OTE1NTksIDAuMzUzNTkxMDI0ODc1NjQxXSxcbiAgICBbMC43NTIyMTE5ODc5NzIyNiwgMC40MTA4MDQ5ODY5NTM3MzVdLFxuICAgIFswLjYwMjkxODAyODgzMTQ4MiwgMC44NDI4NjI5NjM2NzY0NTNdLFxuICAgIFswLjcxOTkwMTk3ODk2OTU3NCwgMC4zNzU1OTk5ODAzNTQzMDldLFxuICAgIFswLjg5MzY5Mjk3MDI3NTg3OSwgMC4zOTk5NTk5ODE0NDE0OThdLFxuICAgIFswLjc5MDA4MTk3Nzg0NDIzOCwgMC4zOTEzNTQwMjQ0MTAyNDhdLFxuICAgIFswLjY0Mzk5ODAyNjg0NzgzOSwgMC41MzQ0ODc5NjI3MjI3NzhdLFxuICAgIFswLjUyODI0OTAyNTM0NDg0OSwgMC42NTA0MDM5NzY0NDA0M10sXG4gICAgWzAuNTI1ODQ5OTk3OTk3Mjg0LCAwLjY4MDE5MTA0MDAzOTA2Ml0sXG4gICAgWzAuNTYwMjE0OTk2MzM3ODkxLCAwLjY1NzIyOTAwNjI5MDQzNl0sXG4gICAgWzAuNTg1Mzg0MDExMjY4NjE2LCAwLjY2NjU0MDk4MDMzOTA1XSxcbiAgICBbMC41NDk2MjU5OTI3NzQ5NjMsIDAuNjgwODYwOTk2MjQ2MzM4XSxcbiAgICBbMC41NzEyMjgwMjczNDM3NSwgMC42ODI2OTE5OTEzMjkxOTNdLFxuICAgIFswLjYyNDg1MjAwMTY2NzAyMywgMC43MjgwOTg5ODg1MzMwMl0sXG4gICAgWzAuNTEzMDUwMDE5NzQxMDU4LCAwLjU0NzI4MTk4MDUxNDUyNl0sXG4gICAgWzAuNTE1MDk3MDIyMDU2NTgsIDAuNTI3MjUxOTU4ODQ3MDQ2XSxcbiAgICBbMC43NDIyNDY5ODU0MzU0ODYsIDAuMzE0NTA3MDA3NTk4ODc3XSxcbiAgICBbMC41OTg2MzEwMjQzNjA2NTcsIDAuNDU0OTc5MDAyNDc1NzM5XSxcbiAgICBbMC41NzAzMzgwMTA3ODc5NjQsIDAuNTQ4NTc1MDQzNjc4Mjg0XSxcbiAgICBbMC41Nzg2MzE5OTcxMDg0NTksIDAuNTMzNjIyOTgwMTE3Nzk4XSxcbiAgICBbMC43MjMwODcwMTI3Njc3OTIsIDAuNTMyMDU0MDA3MDUzMzc1XSxcbiAgICBbMC41MTY0NDU5OTQzNzcxMzYsIDAuNDk5NjM4OTc0NjY2NTk1XSxcbiAgICBbMC42NjI4MDEwMjcyOTc5NzQsIDAuMjgyOTE3OTc2Mzc5Mzk1XSxcbiAgICBbMC43MDM2MjQwMTAwODYwNiwgMC4yOTMyNzEwMDUxNTM2NTZdLFxuICAgIFswLjgzMDcwNDk4NzA0OTEwMywgMC4xOTM4MTM5Nzk2MjU3MDJdLFxuICAgIFswLjU1MjM4NTk4NTg1MTI4OCwgMC4zMDI1NjgwMTg0MzY0MzJdLFxuICAgIFswLjYwNzYwOTk4NzI1ODkxMSwgMC4zNTM4ODc5NzUyMTU5MTJdLFxuICAgIFswLjY0NTQyOTAxNTE1OTYwNywgMC42OTY3MDcwMTAyNjkxNjVdLFxuICAgIFswLjkzMjY5NDk3MTU2MTQzMiwgMC43MzAxMDUwNDI0NTc1ODFdLFxuICAgIFswLjU1NzI2MDk5MDE0MjgyMiwgMC41NzI4MjYwMjc4NzAxNzhdLFxuICAgIFswLjU0MjkwMTk5Mjc5Nzg1MiwgMC41ODQ3OTIwMTc5MzY3MDddLFxuICAgIFswLjYxODAyNjAxODE0MjcsIDAuNjk0NzEwOTY5OTI0OTI3XSxcbiAgICBbMC42MDc1OTA5NzMzNzcyMjgsIDAuNjk0MjAzMDE5MTQyMTUxXSxcbiAgICBbMC43MjI5NDMwMDc5NDYwMTQsIDAuMjcxOTYzMDAwMjk3NTQ2XSxcbiAgICBbMC41Nzc0MTM5NzYxOTI0NzQsIDAuNTYzMTY2OTc1OTc1MDM3XSxcbiAgICBbMC42MTQwODI5OTIwNzY4NzQsIDAuMjgxMzg2OTcxNDczNjk0XSxcbiAgICBbMC42MTY5MDcwMDA1NDE2ODcsIDAuMjU1ODg2MDE4Mjc2MjE1XSxcbiAgICBbMC42Njg1MDkwMDY1MDAyNDQsIDAuMTE5OTEzOTk1MjY1OTYxXSxcbiAgICBbMC43NzAwOTIwMTA0OTgwNDcsIDAuMjMyMDIwOTc0MTU5MjQxXSxcbiAgICBbMC42MzU1MzYwMTUwMzM3MjIsIDAuMTg5MjQ4OTc5MDkxNjQ0XSxcbiAgICBbMC43NzAzOTA5ODczOTYyNCwgMC4yOTk1NTYwMTY5MjE5OTddLFxuICAgIFswLjgyNjcyMjAyNTg3MTI3NywgMC4yNzg3NTUwMDkxNzQzNDddLFxuICAgIFswLjUyNzEyMTAwNzQ0MjQ3NCwgMC42NjYxOTgwMTUyMTMwMTNdLFxuICAgIFswLjU1MzE3MTk5MjMwMTk0MSwgMC42Njg1MjcwMDcxMDI5NjZdLFxuICAgIFswLjU3NzIzODAyMzI4MTA5NywgMC42NzM4ODk5OTQ2MjEyNzddLFxuICAgIFswLjU1NDY5MTk3MDM0ODM1OCwgMC41ODAwNjU5NjU2NTI0NjZdLFxuICAgIFswLjYxMTg5Njk5MTcyOTczNiwgMC42OTM5NjEwMjQyODQzNjNdLFxuICAgIFswLjU5Njk2MTAyMTQyMzM0LCAwLjcwNjUzOTk4ODUxNzc2MV0sXG4gICAgWzAuNTk2MzcwOTk1MDQ0NzA4LCAwLjY5Mzk1MzAzNzI2MTk2M10sXG4gICAgWzAuNTM5OTU4MDAwMTgzMTA1LCAwLjU1NzEzOTAzOTAzOTYxMl0sXG4gICAgWzAuNTY4ODQxOTkzODA4NzQ2LCAwLjY5MjM2NjAwMzk5MDE3M10sXG4gICAgWzAuNTQ3ODE4MDA1MDg0OTkxLCAwLjY5MjM2NjAwMzk5MDE3M10sXG4gICAgWzAuNTI0NjEzMDIyODA0MjYsIDAuNjkyMzY2MDAzOTkwMTczXSxcbiAgICBbMC41MzQwODk5ODI1MDk2MTMsIDAuNzc5MTQxMDA4ODUzOTEyXSxcbiAgICBbMC41Mjc2NzA5Nzk0OTk4MTcsIDAuNzM2MjI1OTYyNjM4ODU1XSxcbiAgICBbMC41MjY5MTI5ODcyMzIyMDgsIDAuNzE3ODU3MDAzMjExOTc1XSxcbiAgICBbMC41MjY4Nzc5OTkzMDU3MjUsIDAuNzA0NjI1OTY0MTY0NzM0XSxcbiAgICBbMC41MjY5NjY5ODkwNDAzNzUsIDAuNjk1Mjc3OTg4OTEwNjc1XSxcbiAgICBbMC41NzIwNTgwMjIwMjIyNDcsIDAuNjk1Mjc3OTg4OTEwNjc1XSxcbiAgICBbMC41NzM1MjEwMTgwMjgyNTksIDAuNzAzNTM5OTY3NTM2OTI2XSxcbiAgICBbMC41NzY4MzgwMTY1MTAwMSwgMC43MTE4NDU5OTM5OTU2NjddLFxuICAgIFswLjU4MTY5MTAyNjY4NzYyMiwgMC43MjAwNjI5NzExMTUxMTJdLFxuICAgIFswLjYwOTk0NDk5OTIxNzk4NywgMC42Mzk5MDk5ODI2ODEyNzRdLFxuICAgIFswLjk4NjA0NjAxNjIxNjI3OCwgMC41NjAwMzQwMzY2MzYzNTNdLFxuICAgIFswLjU4Njc5OTk3OTIwOTksIDAuNjk1Mzk5OTk5NjE4NTNdLFxuICAgIFswLjU5MDM3MjAyNTk2NjY0NCwgMC43MDE4MjI5OTYxMzk1MjZdLFxuICAgIFswLjUzMTkxNTAwOTAyMTc1OSwgMC42MDE1MzY5ODkyMTIwMzZdLFxuICAgIFswLjU3NzI2ODAwNDQxNzQxOSwgMC41ODU5MzQ5OTY2MDQ5MTldLFxuICAgIFswLjUzNjkxNTAwNDI1MzM4NywgMC41OTM3ODYwMDEyMDU0NDRdLFxuICAgIFswLjYyNzU0Mjk3MjU2NDY5NywgMC40NzMzNTIwMTUwMTg0NjNdLFxuICAgIFswLjY2NTU4NTk5NDcyMDQ1OSwgMC40OTU5NTA5OTY4NzU3NjNdLFxuICAgIFswLjU4ODM1Mzk5MTUwODQ4NCwgMC41NDY4NjIwMDYxODc0MzldLFxuICAgIFswLjc1NzgyNDAwMzY5NjQ0MiwgMC4xNDc2NzU5OTEwNTgzNV0sXG4gICAgWzAuNzA5MjQ5OTczMjk3MTE5LCAwLjIwMTUwNzk4NTU5MTg4OF0sXG4gICAgWzAuNjcyNjg0MDEzODQzNTM2LCAwLjI1NjU4MTAwODQzNDI5Nl0sXG4gICAgWzAuNjAwNDA4OTcxMzA5NjYyLCAwLjc0OTAwNDk2MDA2MDEyXSxcbiAgICBbMC41NTgyNjU5ODQwNTgzOCwgMC4yNjE2NzIwMTk5NTg0OTZdLFxuICAgIFswLjU3MDMwMzk3NjUzNTc5NywgMC4xODc4NzA5NzkzMDkwODJdLFxuICAgIFswLjU4ODE2NTk5ODQ1ODg2MiwgMC4xMDkwNDQwMTU0MDc1NjJdLFxuICAgIFswLjcxMTA0NTAyNjc3OTE3NSwgMC4zOTg5NTIwMDcyOTM3MDFdLFxuICAgIFswLjc4MTA2OTk5Mzk3Mjc3OCwgMC40MzU0MDUwMTU5NDU0MzVdLFxuICAgIFswLjU4NzI0NzAxNDA0NTcxNSwgMC4zOTg5MzE5ODAxMzMwNTddLFxuICAgIFswLjc0Mjg2OTk3MzE4MjY3OCwgMC4zNTU0NDU5ODEwMjU2OTZdLFxuICAgIFswLjU3MjE1NjAxMjA1ODI1OCwgMC40Mzc2NTE5OTE4NDQxNzddLFxuICAgIFswLjU1MTg2ODAyMTQ4ODE5LCAwLjUzNjU3MDAxMjU2OTQyN10sXG4gICAgWzAuODIxNDQyMDA4MDE4NDk0LCAwLjQ1NzU1NjAwOTI5MjYwM10sXG4gICAgWzAuNzUyNzAxOTk3NzU2OTU4LCAwLjQ1NzE4MTk5MDE0NjYzN10sXG4gICAgWzAuNzEzNzU2OTc4NTExODEsIDAuNDY3NjI2OTg4ODg3Nzg3XSxcbiAgICBbMC42NjcxMTMwMDYxMTQ5NiwgMC40NjA2NzI5NzQ1ODY0ODddLFxuICAgIFswLjYzMTEwMTAxMjIyOTkxOSwgMC40NDcxNTM5ODU1MDAzMzZdLFxuICAgIFswLjYwMDg2MjAyNjIxNDYsIDAuNDMyNDczMDAzODY0Mjg4XSxcbiAgICBbMC41MjM0ODEwMTEzOTA2ODYsIDAuNDA1NjI3MDEyMjUyODA4XSxcbiAgICBbMC44MTA3NDc5ODEwNzE0NzIsIDAuNTIzOTI2MDE5NjY4NTc5XSxcbiAgICBbMC43NzEwNDU5ODI4Mzc2NzcsIDAuMzQ4OTU5MDI4NzIwODU2XSxcbiAgICBbMC41MDkxMjcwMjA4MzU4NzYsIDAuNTYyNzE4MDMzNzkwNTg4XSxcbiAgICBbMC41OTUyOTI5ODU0MzkzMDEsIDAuNDg1MDIzOTc1MzcyMzE0XSxcbiAgICBbMC45ODA1MzA5NzcyNDkxNDYsIDAuNDAxNTY0MDAyMDM3MDQ4XSxcbiAgICBbMC41NzM0OTk5Nzc1ODg2NTQsIDAuNDIwMDAwMDE2Njg5MzAxXSxcbiAgICBbMC42MDI5OTQ5Nzg0Mjc4ODcsIDAuNTQ4Njg3OTk0NDgwMTMzXSxcbiAgICBbMC43MzM1Mjk5ODQ5NTEwMTksIDAuMzc2OTc3MDI2NDYyNTU1XSxcbiAgICBbMC41NjA2MTEwMDk1OTc3NzgsIDAuNTE5MDE2OTgxMTI0ODc4XSxcbiAgICBbMC45Njc2ODU5OTc0ODYxMTUsIDAuNjQ0MzU2OTY2MDE4Njc3XSxcbiAgICBbMC41ODA5ODUwMDk2NzAyNTgsIDAuMzg3MTYwMDAzMTg1MjcyXSxcbiAgICBbMC41Mzc3MjgwMTE2MDgxMjQsIDAuNTA1Mzg1MDQxMjM2ODc3XSxcbiAgICBbMC43NjA5NjYwMDI5NDExMzIsIDAuNzc5NzUyOTY5NzQxODIxXSxcbiAgICBbMC44MDE3Nzg5NzIxNDg4OTUsIDAuODMxOTM4MDI4MzM1NTcxXSxcbiAgICBbMC44OTI0NDA5NzQ3MTIzNzIsIDAuNTQwNzYwOTkzOTU3NTJdLFxuICAgIFswLjgxNjM1MDk5NjQ5NDI5MywgMC43NDAyNjAwMDQ5OTcyNTNdLFxuICAgIFswLjg2NTU5NDk4MzEwMDg5MSwgMC4zMzM2ODcwMDc0MjcyMTZdLFxuICAgIFswLjYxNDA3Mzk5MTc3NTUxMywgMC44ODMyNDYwMDQ1ODE0NTFdLFxuICAgIFswLjUwODk1Mjk3NTI3MzEzMiwgMC41Nzk0Mzc5NzExMTUxMTJdLFxuICAgIFswLjYxNzk0MTk3NTU5MzU2NywgMC41MDgzMTYwNDAwMzkwNjJdLFxuICAgIFswLjgyNTYwODAxNTA2MDQyNSwgMC4zOTc2NzQ5Nzc3NzkzODhdLFxuICAgIFswLjY4MTIxNDk4ODIzMTY1OSwgMC4zOTYyMzQ5ODkxNjYyNl0sXG4gICAgWzAuNjU2NjM1OTk5Njc5NTY1LCAwLjQwMDU5Njk3NjI4MDIxMl0sXG4gICAgWzAuNjAzOTAwMDE1MzU0MTU2LCAwLjcxMDIxNjk5OTA1Mzk1NV0sXG4gICAgWzAuODEyMDg1OTg2MTM3MzksIDAuNTg4NTM5MDA0MzI1ODY3XSxcbiAgICBbMC41NjgwMTMwMTI0MDkyMSwgMC45NDQ1NjQ5OTgxNDk4NzJdLFxuICAgIFswLjY4MTAwNzk4MTMwMDM1NCwgMC44OTgyODUwMzEzMTg2NjVdLFxuICAgIFswLjczMzc1MjAxMjI1MjgwOCwgMC44Njk3MDEwMjc4NzAxNzhdLFxuICAgIFswLjYzMzgzMDAxMDg5MDk2MSwgMC4zOTg4MjIwMDk1NjM0NDZdLFxuICAgIFswLjYwNjc5Mjk4NjM5Mjk3NSwgMC4zOTU1MzcwMTg3NzU5NF0sXG4gICAgWzAuNTg5NjU5OTg4ODgwMTU3LCAwLjM5MTA2MjAyMTI1NTQ5M10sXG4gICAgWzAuODA1MDE1OTgxMTk3MzU3LCAwLjM0MjEwODAxMTI0NTcyOF0sXG4gICAgWzAuNjExMzM0OTc5NTM0MTQ5LCAwLjM2MjI4NDAwNDY4ODI2M10sXG4gICAgWzAuNjM0MDM3OTcxNDk2NTgyLCAwLjM1NTk3MDk3ODczNjg3N10sXG4gICAgWzAuNjU2NjM1OTk5Njc5NTY1LCAwLjM1NTM1Njk5MTI5MTA0Nl0sXG4gICAgWzAuNjgxMjE0OTg4MjMxNjU5LCAwLjM1ODM0MDAyNDk0ODEyXSxcbiAgICBbMC42OTg1ODQ5NzM4MTIxMDMsIDAuMzYzMTU2MDIwNjQxMzI3XSxcbiAgICBbMC45NDE4NjY5OTM5MDQxMTQsIDAuMzE5MDc2MDAxNjQ0MTM1XSxcbiAgICBbMC42OTg1ODQ5NzM4MTIxMDMsIDAuMzg3NDQ5MDI2MTA3Nzg4XSxcbiAgICBbMC41ODQxNzcwMTcyMTE5MTQsIDAuNjI0MTA3MDAzMjExOTc1XSxcbiAgICBbMC41NTQzMTgwMTA4MDcwMzcsIDAuNTY2MDc2OTkzOTQyMjYxXSxcbiAgICBbMC41MzQxNTM5OTc4OTgxMDIsIDAuNjIwNjQwMDM5NDQzOTddLFxuICAgIFswLjcxMTIxNzk5OTQ1ODMxMywgMC44MTk5NzUwMTg1MDEyODJdLFxuICAgIFswLjY2NDYyOTk5NTgyMjkwNiwgMC44NTI4NzEwMDA3NjY3NTRdLFxuICAgIFswLjU1OTA5OTk3MjI0ODA3NywgMC45MDI2MzE5OTgwNjIxMzRdLFxuICAgIFswLjg3MTcwNjAwODkxMTEzMywgMC43OTE5NDA5ODcxMTAxMzhdLFxuICAgIFswLjU5MTIzNDAyODMzOTM4NiwgMC4zNzM4OTM5NzYyMTE1NDhdLFxuICAgIFswLjU0NDM0MTAyNzczNjY2NCwgMC40NTE1ODM5ODE1MTM5NzddLFxuICAgIFswLjYyNDU2Mjk3ODc0NDUwNywgMC45MjQxOTIwMTEzNTYzNTRdLFxuICAgIFswLjg4NTc3MDAyMjg2OTExLCAwLjYxNTAyODk3NzM5NDEwNF0sXG4gICAgWzAuNTUxMzM4MDE2OTg2ODQ3LCAwLjY5NTI3Nzk4ODkxMDY3NV0sXG4gICAgWzAuNTUxOTgwMDE4NjE1NzIzLCAwLjcwNDYzMjA0MzgzODUwMV0sXG4gICAgWzAuNTUyODg3OTc2MTY5NTg2LCAwLjcxNTgwODAzMzk0MzE3Nl0sXG4gICAgWzAuNTU1MTY3OTczMDQxNTM0LCAwLjczMDc5NDAxMjU0NjUzOV0sXG4gICAgWzAuNTY5OTQ0MDI0MDg1OTk5LCAwLjc2NzAzNTAwNzQ3NjgwN10sXG4gICAgWzAuNTkzMjAzMDA4MTc0ODk2LCAwLjY4NTY3NTk3ODY2MDU4M10sXG4gICAgWzAuNTk5MjYxOTk5MTMwMjQ5LCAwLjY4MTA2OTAxNjQ1NjYwNF0sXG4gICAgWzAuNjA3NTk5OTczNjc4NTg5LCAwLjY3NzcwMzAyMjk1Njg0OF0sXG4gICAgWzAuNjMxOTM3OTgwNjUxODU1LCAwLjY2MzUwMDAxMDk2NzI1NV0sXG4gICAgWzAuNzUyMDMyOTk1MjIzOTk5LCAwLjYwMTMxNTAyMTUxNDg5M10sXG4gICAgWzAuNTQ3MjI2MDExNzUzMDgyLCAwLjQyMDM5NTAxNjY3MDIyN10sXG4gICAgWzAuNTYzNTQzOTc1MzUzMjQxLCAwLjM1OTgyNzk5NTMwMDI5M10sXG4gICAgWzAuNTgzODQxMDI1ODI5MzE1LCAwLjM2ODcxMzk3NDk1MjY5OF0sXG4gICAgWzAuNTg2NjE0MDEyNzE4MjAxLCAwLjY5MjM2NjAwMzk5MDE3M10sXG4gICAgWzAuNzcxOTE1MDE4NTU4NTAyLCAwLjY4MzU3ODAxNDM3Mzc3OV0sXG4gICAgWzAuNTMxNTk3MDE4MjQxODgyLCAwLjM1MjQ4Mjk3NDUyOTI2Nl0sXG4gICAgWzAuNTg4MzcwOTc4ODMyMjQ1LCAwLjgwNDQ0MDk3NTE4OTIwOV0sXG4gICAgWzAuNTIwNzk3MDE0MjM2NDUsIDAuNDQyNTY1MDIzODk5MDc4XSxcbiAgICBbMC41Njc5ODQ5OTgyMjYxNjYsIDAuNDkzNDc5MDEzNDQyOTkzXSxcbiAgICBbMC41NDMyODI5ODU2ODcyNTYsIDAuODE5MjU0OTk0MzkyMzk1XSxcbiAgICBbMC42NTUzMTcwMDg0OTUzMzEsIDAuNzQ1NTE0OTg4ODk5MjMxXSxcbiAgICBbMC42MjEwMDg5OTIxOTUxMjksIDAuNTc0MDE4MDAxNTU2Mzk2XSxcbiAgICBbMC42MjU1NTk5ODU2Mzc2NjUsIDAuNzgwMzEyMDAxNzA1MTddLFxuICAgIFswLjY4MDE5ODAxMzc4MjUwMSwgMC41NzA3MTkwMDM2NzczNjhdLFxuICAgIFswLjY0Mjc2Mzk3MjI4MjQxLCAwLjYwNDMzNzk5MDI4Mzk2Nl0sXG4gICAgWzAuNzA0NjYyOTc4NjQ5MTM5LCAwLjYyMTUyOTk5NjM5NTExMV0sXG4gICAgWzAuNTUyMDEyMDI2MzA5OTY3LCAwLjg2MjU5MTk4MTg4NzgxN10sXG4gICAgWzAuNTg5MDcxOTg5MDU5NDQ4LCAwLjUwODYzNzAxMTA1MTE3OF0sXG4gICAgWzAuNjg1OTQ0OTc0NDIyNDU1LCAwLjc3NTM1NzAwNzk4MDM0N10sXG4gICAgWzAuNjQ1NzM1MDI1NDA1ODg0LCAwLjgxMjY0MDAxMTMxMDU3N10sXG4gICAgWzAuNjc1MzQyOTc3MDQ2OTY3LCAwLjcwMzk3ODAwMjA3MTM4MV0sXG4gICAgWzAuODEwODU4MDExMjQ1NzI4LCAwLjY0NjMwNDk2NTAxOTIyNl0sXG4gICAgWzAuNzIwMTIxOTc5NzEzNDQsIDAuNzE0NjY2OTYyNjIzNTk2XSxcbiAgICBbMC44NjYxNTE5ODg1MDYzMTcsIDAuNjgyNzA0OTg1MTQxNzU0XSxcbiAgICBbMC42NjMxODcwMjY5Nzc1MzksIDAuNjQ0NTk2OTkzOTIzMTg3XSxcbiAgICBbMC41NzAwODIwMDg4Mzg2NTQsIDAuNDY2MzI1OTk4MzA2Mjc0XSxcbiAgICBbMC41NDQ1NjE5ODIxNTQ4NDYsIDAuNTQ4Mzc1OTY0MTY0NzM0XSxcbiAgICBbMC41NjI3NTg5ODIxODE1NDksIDAuNTU4Nzg0OTYxNzAwNDM5XSxcbiAgICBbMC41MzE5ODcwMTE0MzI2NDgsIDAuNTMwMTQwMDQyMzA0OTkzXSxcbiAgICBbMC41ODUyNzEwMDA4NjIxMjIsIDAuMzM1MTc3MDA0MzM3MzExXSxcbiAgICBbMC42MjI5NTI5OTc2ODQ0NzksIDAuMzIyNzc4OTk5ODA1NDVdLFxuICAgIFswLjY1NTg5NjAwODAxNDY3OSwgMC4zMjAxNjMwMTE1NTA5MDNdLFxuICAgIFswLjY4NzEzMjAwMDkyMzE1NywgMC4zMjIzNDU5NzIwNjExNTddLFxuICAgIFswLjcxNjQ4MTk4MzY2MTY1MiwgMC4zMzMyMDA5OTExNTM3MTddLFxuICAgIFswLjc1ODc1Njk5NTIwMTExMSwgMC4zODI3ODY5ODkyMTIwMzZdLFxuICAgIFswLjg5NzAxMzAwODU5NDUxMywgMC40Njg3NjkwMTM4ODE2ODNdLFxuICAgIFswLjczMjM5MjAxMzA3Mjk2OCwgMC40MjQ1NDcwMTY2MjA2MzZdLFxuICAgIFswLjcwMjExMzk4NjAxNTMyLCAwLjQzMzE2Mjk4NzIzMjIwOF0sXG4gICAgWzAuNjY2NTI1MDA2Mjk0MjUsIDAuNDMzODY2MDI0MDE3MzM0XSxcbiAgICBbMC42MzM1MDQ5ODY3NjMsIDAuNDI2MDg3OTc1NTAyMDE0XSxcbiAgICBbMC42MDM4NzU5OTQ2ODIzMTIsIDAuNDE2NTg2OTk1MTI0ODE3XSxcbiAgICBbMC41Nzk2NTc5NzE4NTg5NzgsIDAuNDA5OTQ1MDExMTM4OTE2XSxcbiAgICBbMC45OTI0Mzk5ODUyNzUyNjksIDAuNDgwNzc3MDI1MjIyNzc4XSxcbiAgICBbMC41NjcxOTIwMTgwMzIwNzQsIDAuNTY5NDE5OTgwMDQ5MTMzXSxcbiAgICBbMC41NDEzNjU5ODExMDE5OSwgMC40Nzg4OTkwMDIwNzUxOTVdLFxuICAgIFswLjUyNjU2NDAwMjAzNzA0OCwgMC41NDYxMTgwMjEwMTEzNTNdLFxuICAgIFswLjUyMzkxMzAyNTg1NjAxOCwgMC41NjM4MzAwMTgwNDM1MThdLFxuICAgIFswLjUzMTUyOTAwOTM0MjE5NCwgMC41NTUwNTY5ODkxOTI5NjNdLFxuICAgIFswLjU2NjAzNTk4NTk0NjY1NSwgMC41ODIzMjkwMzQ4MDUyOThdLFxuICAgIFswLjUxNjMxMDk4OTg1NjcyLCAwLjU2MzA1Mzk2NTU2ODU0Ml0sXG4gICAgWzAuNTE3NDcyMDI4NzMyMywgMC41Nzc4NzcwNDQ2Nzc3MzRdLFxuICAgIFswLjU3MzU5NDk4NzM5MjQyNiwgMC4zODk4MDY5ODU4NTUxMDNdLFxuICAgIFswLjU2MDY5Nzk3Mjc3NDUwNiwgMC4zOTUzMzE5Nzg3OTc5MTNdLFxuICAgIFswLjU0OTc1NTk5MDUwNTIxOSwgMC4zOTk3NTEwMDc1NTY5MTVdLFxuICAgIFswLjcxMDI4Nzk4ODE4NTg4MywgMC4zNjgyNTI5OTI2MzAwMDVdLFxuICAgIFswLjcyMzMzMDAyMDkwNDU0MSwgMC4zNjMzNzI5ODE1NDgzMDldXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXZfY29vcmRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/uv_coords.js\n");

/***/ })

};
;